Charte graphique & palette de couleurs : On adoptera une palette moderne, Ã©voquant la science tout en restant joyeuse. Par exemple, on peut partir sur un fond clair neutre et utiliser des couleurs vives pour les diffÃ©rents types dâ€™Ã©lÃ©ments (comme câ€™est lâ€™usage dans les tableaux pÃ©riodiquesÂ : mÃ©taux alcalins en rose/rouge, mÃ©taux de transition en vert ou bleu, gaz nobles en pourpre, etc.). Ces couleurs serviront de repÃ¨res visuels. Il faudra aussi une palette secondaire pour lâ€™UI (boutons, en-tÃªtesâ€¦). On choisira 2 ou 3 couleurs principales harmonieuses (par ex. un bleu pÃ©trole pour le header, rappelant la confiance scientifique, combinÃ© Ã  une couleur dâ€™accent plus vive â€“ orange ou vert â€“ pour les surbrillances ludiques). Le contraste sera suffisant pour assurer la lisibilitÃ© (texte blanc sur fond colorÃ© pour les labels dâ€™Ã©lÃ©ments par ex.). On peut Ã©galement prÃ©voir un mode sombre en option, vu la popularitÃ© de cette fonctionnalitÃ© â€“ Tailwind facilite la gestion de thÃ¨mes (classes dark:).
Typographie et lisibilitÃ© : Opter pour une police sans-serif moderne, facile Ã  lire Ã  lâ€™Ã©cran (par ex. Inter, Roboto ou Source Sans Pro). Les titres dâ€™Ã©lÃ©ments pourraient Ãªtre dans une font un peu plus fun ou stylÃ©e, mais il faut rester sobre pour le corps du texte. Les tailles de police seront modulaires : suffisamment grandes pour Ãªtre lisibles mÃªme sur mobile (au moins 14px pour le texte de base, 10-12px minimum pour les numÃ©ros atomiques sur la grille qui seront de toute faÃ§on trÃ¨s courts). Lâ€™usage de Tailwind permettra dâ€™appliquer des espacements cohÃ©rents (marges/paddings suivant une Ã©chelle 4,8,16px etc.) assurant une mise en page aÃ©rÃ©e. Les paragraphes de description seront concis (2-3 phrases max) et sÃ©parÃ©s par des espacements pour ne pas former un bloc compact. On veillera aux alignements (par ex. aligner les cases dâ€™Ã©lÃ©ments bien en grille, aligner les titres et textes dans la fiche Ã©lÃ©ment). Lâ€™UI doit paraÃ®tre propre et organisÃ©e.
Disposition et navigation : Sur desktop, on peut afficher le tableau pÃ©riodique en pleine largeur (responsive, centrÃ©). Un menu ou une barre supÃ©rieure contiendra la recherche et dâ€™Ã©ventuels boutons (filtre, switch de langue, toggle sombre). La fiche dâ€™un Ã©lÃ©ment sâ€™ouvrira soit dans un panneau latÃ©ral escamotable, soit dans une modal centrÃ©e. Le choix dÃ©pendra des tests UX : un panneau latÃ©ral permet de garder le tableau visible en arriÃ¨re-plan, ce qui aide Ã  se situer (contexte), tandis quâ€™une modal centrÃ©e focalise lâ€™attention sur lâ€™Ã©lÃ©ment (et le tableau pourrait Ãªtre en fond assombri). On pourrait implÃ©menter lâ€™un puis Ã©valuer. Sur mobile, si lâ€™Ã©cran est petit, il serait peut-Ãªtre prÃ©fÃ©rable quâ€™un clic ouvre la fiche en plein Ã©cran (une nouvelle vue) pour utiliser tout lâ€™espace disponible verticalement. Dans ce cas, un bouton de retour (back) ou une croix de fermeture sera bien visible pour revenir au tableau.
Interactions intuitives : Chaque Ã©lÃ©ment de la grille sera rendu comme un bouton (accessibilitÃ© ARIA) : il change de style au survol (highlight) et au focus (pour navigation clavier). Cliquer/toucher dÃ©clenche lâ€™ouverture de la fiche. Le survol peut aussi afficher une mini-info-bulle avec le nom complet de lâ€™Ã©lÃ©ment si lâ€™affichage est rÃ©duit (utile sur mobile ou si on nâ€™affiche que le symbole). La recherche doit Ãªtre accessible via un raccourci (par ex. appui sur la touche "/" pour focus la barre de recherche, comme sur beaucoup de sites, ce qui est pratique pour les power-users). Les filtres auront des libellÃ©s clairs et une indication visuelle lorsquâ€™ils sont actifs (par ex. bouton en surbrillance). En activant un filtre, on pourrait animer les cases non correspondantes en les grisant ou en les masquant avec une transition douce, pour bien signaler le rÃ©sultat du filtre.
Animations et micro-interactions : Lâ€™usage de GSAP/Framer Motion sera ciblÃ© sur des animations qualitatives :
Lors du chargement initial, on peut animer lâ€™apparition du tableau (par ex. les cases qui se mettent en place avec un lÃ©ger dÃ©calage, ou un effet de fade-in global).
Lorsquâ€™un Ã©lÃ©ment est cliquÃ©, sa carte de dÃ©tail peut apparaÃ®tre avec un effet sympa â€“ par exemple, une transition qui zoome depuis la case cliquÃ©e vers le panneau de dÃ©tail (donnant lâ€™impression que la case sâ€™agrandit pour devenir la fiche). Alternativement, un effet de flip card: la case se retourne pour montrer son verso (contenant les infos). Ce type dâ€™animation rend lâ€™expÃ©rience plus tangible.
Les transitions page/retour sur mobile (si on change de route) seront optimisÃ©es pour sembler natives (glissement latÃ©ral, etc., cohÃ©rent avec les guidelines iOS/Material).
De petites animations de survol : par ex., un hover sur les boutons de filtre fait apparaÃ®tre un tooltip explicatif, un shake lÃ©ger dâ€™un icÃ´ne de filtre pour attirer lâ€™attention si lâ€™utilisateur semble chercher quelque chose, etc., mais sans excÃ¨s pour ne pas distraire inutilement.
Performance : toutes les animations devront Ãªtre fluides (60 fps idÃ©alement) et non bloquantes. On utilisera les capacitÃ©s de CSS (transitions GPU) ou GSAP timeline optimisÃ©es. De plus, prÃ©voir une dÃ©gradation Ã©lÃ©gante : si lâ€™appareil de lâ€™utilisateur est ancien ou si lâ€™option â€œrÃ©duire les animationsâ€ est activÃ©e dans son OS, nos animations doivent soit se dÃ©sactiver, soit Ãªtre trÃ¨s allÃ©gÃ©es pour privilÃ©gier la lisibilitÃ©.
Illustrations et Ã©lÃ©ments visuels : Pour le cÃ´tÃ© fun, on intÃ¨grera des petites illustrations ou emojis/mÃªmes Ã  dose mesurÃ©e. Par exemple, Ã  cÃ´tÃ© de lâ€™anecdote amusante, un petit emoji ğŸ˜œ ou une icÃ´ne humoristique peut signaler le ton lÃ©ger. On peut imaginer que chaque Ã©lÃ©ment ait un pictogramme ou une mini-image associÃ©e symbolisant un usage (Ã  la maniÃ¨re du tableau illustrÃ© en images vu plus haut). On pourrait rÃ©utiliser des images libres de droit ou des pictos stylisÃ©s (pack dâ€™icÃ´nes type FontAwesome ou HeroIcons, ou des illustrations SVG custom). Ces visuels doivent rester secondaires par rapport au texte, pour ne pas surcharger lâ€™UI. Un Ã©quilibre est Ã  trouver entre enrichir visuellement et garder une interface claire.
Consistance et feedback utilisateur : Lâ€™expÃ©rience sera uniformisÃ©e : mÃªmes codes couleur pour les mÃªmes catÃ©gories partout, style cohÃ©rent entre les boutons, champs, etc. (dâ€™oÃ¹ lâ€™intÃ©rÃªt de shadcn/ui ou au moins de suivre un design system). Chaque action utilisateur doit avoir un retour visuel : un clic sur un Ã©lÃ©ment donne lâ€™impression de bouton enfoncÃ©, lâ€™ouverture dâ€™une fiche fait apparaÃ®tre un nouveau contenu de maniÃ¨re Ã©vidente. Si un filtre nâ€™a aucun rÃ©sultat (par ex. filtrer â€œgazâ€ puis â€œsolideâ€ en mÃªme temps, contradiction), le site affichera un petit message (â€œAucun Ã©lÃ©mentâ€) ou une indication pour Ã©viter la confusion.
En appliquant ces guidelines, on obtiendra une interface intuitive, esthÃ©tique et fluide. Lâ€™utilisateur pourra naviguer avec plaisir, en comprenant rapidement comment interagir (grÃ¢ce aux indices visuels) et en profitant dâ€™une prÃ©sentation claire de lâ€™information. Lâ€™aspect ludique (animations, anecdotes, visuels) gardera son intÃ©rÃªt sans compromettre la rigueur ni la performance.
6. Architecture de routing et logique de navigation
MÃªme sans utiliser SvelteKit, nous devons organiser lâ€™application en plusieurs vues/pages logiques pour structurer la navigation. Ã‰tant une SPA (single-page app) Svelte, le routing sera gÃ©rÃ© cÃ´tÃ© client, mais il faut le penser comme un enchaÃ®nement de â€œpagesâ€ pour lâ€™utilisateur. Voici une proposition dâ€™architecture de navigationÂ :
Page dâ€™accueil â€“ Tableau pÃ©riodique : Lâ€™URL de base (par ex. / ou /index.html) affichera le tableau pÃ©riodique complet. Câ€™est la vue principale contenant :
La grille interactive des Ã©lÃ©ments (composant <PeriodicTable>).
La barre de recherche et les contrÃ´les de filtre (composant <Toolbar> en haut, Ã©ventuellement).
Peut-Ãªtre une introduction courte ou un encart â€œsaviez-vous que?â€ qui accueille lâ€™utilisateur la premiÃ¨re fois, mais le focus reste sur la table.
En mode desktop, tout est sur une page. En mode mobile, cette page scrollable permet dÃ©jÃ  de naviguer dans la table.
Page dÃ©tail dâ€™un Ã©lÃ©ment : Accessible via une route de type /element/Â«Â symboleÂ Â» ou /element/Â«Â numÃ©roÂ Â». Par exemple /element/Fe pour le fer ou /element/26 (selon quâ€™on choisit symbole ou numÃ©ro dans lâ€™URL). Cette page dÃ©tail affichera le composant <ElementDetails> qui prÃ©sente les informations complÃ¨tes sur lâ€™Ã©lÃ©ment sÃ©lectionnÃ© (description, usages, anecdote, etc. comme dÃ©fini dans le cahier des charges).
Sur desktop, on peut rÃ©aliser ceci avec un routeur interne sans rÃ©ellement changer de page : par exemple, si lâ€™URL change, on affiche la fiche en overlay tout en restant sur la mÃªme page. Mais conceptuellement, câ€™est une page distincte.
Sur mobile ou si lâ€™utilisateur accÃ¨de directement Ã  cette URL, lâ€™app SPA doit Ãªtre capable de rendre le dÃ©tail seul (il faut donc que lâ€™Ã©tat de lâ€™application gÃ¨re ce cas, par ex. en lisant le paramÃ¨tre de route et en affichant directement lâ€™Ã©lÃ©ment).
La page dÃ©tail comportera un bouton/back pour revenir Ã  la vue tableau (peut Ãªtre implÃ©mentÃ© via window.history.back() ou un lien vers /). On peut aussi offrir des boutons â€œPrÃ©cÃ©dent/Suivantâ€ Ã©lÃ©ment pour feuilleter les Ã©lÃ©ments voisins (utile dans un contexte dâ€™apprentissage sÃ©quentiel, mais pas strictement nÃ©cessaire).
Lâ€™URL distincte est importante pour le partage : lâ€™utilisateur pourra envoyer un lien direct vers la page dâ€™un Ã©lÃ©ment particulier Ã  quelquâ€™un dâ€™autre.
Pages annexes : Bien que non exigÃ©es explicitement, on peut envisager de petites pages complÃ©mentaires pour complÃ©ter le site :
Une page â€œÃ€ proposâ€ (/about par ex.) prÃ©sentant le projet, les auteurs, les sources des donnÃ©es (crÃ©dits Wikipedia, etc.) et les remerciements. Ceci est une bonne pratique et peut Ãªtre utile pour respecter les licences (par ex. si on rÃ©utilise des contenus CC-BY-SA de Wiki).
Une page â€œGuideâ€ ou â€œAideâ€ qui explique comment utiliser les filtres, la recherche, et Ã©ventuellement un rappel de ce que signifient les codes couleur du tableau, etc. Ce pourrait Ãªtre un simple modal dâ€™aide plutÃ´t quâ€™une page Ã  part entiÃ¨re.
Si on pousse la dimension pÃ©dagogique, une page â€œQuizâ€ ou â€œJeuâ€ pourrait Ãªtre imaginÃ©e plus tard (ex: trouver lâ€™Ã©lÃ©ment Ã  partir dâ€™une devinette), mais ce nâ€™est pas dans le pÃ©rimÃ¨tre initial.
En termes de logique de navigation, voici comment cela se traduitÂ :
Par dÃ©faut, lâ€™application charge la vue tableau. Si lâ€™URL contient dÃ©jÃ  un hash/chemin vers un Ã©lÃ©ment, le routeur doit dÃ©tecter ce paramÃ¨tre et afficher directement lâ€™Ã©lÃ©ment concernÃ©.
Cliquer sur un Ã©lÃ©ment dÃ©clenche une action de navigation interne : par exemple, on pourrait utiliser location.hash = "#/element/Fe" pour mettre Ã  jour lâ€™URL (ou utiliser lâ€™History API pour push un Ã©tat /element/Fe sans recharger la page). Svelte, combinÃ© avec un mini-routeur, va alors rendre la vue dÃ©tail.
Lâ€™application doit gÃ©rer la navigation avant/arriÃ¨re du navigateur : si lâ€™utilisateur appuie sur â€œretourâ€ aprÃ¨s avoir vu un Ã©lÃ©ment, il revient Ã  la table (Ã©tat prÃ©cÃ©dent). Inversement, sâ€™il clique un Ã©lÃ©ment, lâ€™historique avance.
Le passage de la page table Ã  la page dÃ©tail peut Ãªtre animÃ© (comme mentionnÃ© en UX). Techniquement, on peut soit garder le composant tableau montÃ© et superposer le dÃ©tail, soit dÃ©truire/monter selon la route. Ã‰tant donnÃ© que le tableau nâ€™est pas lourd (118 Ã©lÃ©ments), on peut le laisser en arriÃ¨re-plan pour un retour instantanÃ©.
Pour la recherche : si lâ€™utilisateur tape dans la barre de recherche un nom dâ€™Ã©lÃ©ment et valide, on peut soit filtrer la vue tableau (par ex. zoomer ou isoler lâ€™Ã©lÃ©ment correspondant dans la grille), soit le rediriger directement vers la page dÃ©tail de cet Ã©lÃ©ment sâ€™il y a correspondance exacte. Une UX pratique serait dâ€™avoir les deux : suggestions en dropdown sous le champ de recherche, cliquer une suggestion amÃ¨ne Ã  la page de lâ€™Ã©lÃ©ment.
Pour les filtres : il sâ€™agit plus dâ€™une interaction sur la page tableau elle-mÃªme que de vraies pages. Par exemple, sÃ©lectionner un filtre â€œmÃ©tauxâ€ ne change pas de route, Ã§a agit sur le composant tableau (on ne va pas faire une route par filtre combinatoire). On pourrait cependant reflÃ©ter lâ€™Ã©tat de filtre dans lâ€™URL via une query string ou un hash (ex: /#?filter=metal), mais ce nâ€™est pas indispensable. Lâ€™important est que lâ€™utilisateur puisse combiner plusieurs critÃ¨res et que la vue se mette Ã  jour en consÃ©quence.
ImplÃ©mentation technique du routing : Sans SvelteKit, on peut utiliser un routeur lÃ©ger. Par exemple, svelte-spa-router (une lib communautaire) ou simplement Ã©crire une fonction qui lit window.location.pathname ou hash et montre le bon composant. Une architecture possible est dâ€™avoir dans App.svelte un bloc {#if} qui choisit le composant Ã  montrer selon une store currentRoute. PseudocodeÂ :
svelte
Copier
Modifier
<script>
  import PeriodicTable from './PeriodicTable.svelte';
  import ElementDetails from './ElementDetails.svelte';
  $: route = $currentRoute; // store that updates on popstate or hashchange
</script>

{#if route.page === 'home'}
  <PeriodicTable />
{:elseif route.page === 'element'}
  <ElementDetails elementId={route.param} />
{:elseif route.page === 'about'}
  <AboutPage/>
{/if}
On mettra en place les listeners sur window.onpopstate pour maj currentRoute, et utiliser history.pushState lors des navigations internes. Ce schÃ©ma assurera une navigation fluide sans rechargement. En rÃ©sumÃ©, lâ€™application aura deux vues principales (tableau et dÃ©tail), Ã©ventuellement enrichies de 1-2 pages info. La navigation devra Ãªtre intuitive (simuler un vrai site multi-pages tout en restant une SPA) et gÃ©rer lâ€™URL pour lâ€™accÃ¨s direct et le partage. Cette architecture garantit que le site se comporte comme une application moderne : un utilisateur peut bookmarker la page dâ€™un Ã©lÃ©ment, y accÃ©der directement, et revenir Ã  la table sans confusion.
7. Contraintes techniques (responsive, i18n, performances, etc.)
Lors du dÃ©veloppement, plusieurs contraintes techniques transversales devront Ãªtre respectÃ©es pour assurer la qualitÃ© du produit final :
Responsive design : Câ€™est un point crucial compte tenu de la nature du tableau pÃ©riodique. On devra tester lâ€™affichage sur diverses rÃ©solutions :
Mobile (~360px de large) : Le tableau de 18 colonnes + 2 rangÃ©es dÃ©tachÃ©es (lanthanides/actinides) ne tiendra pas en une seule vue sans scroll. Solutions : autoriser un scroll horizontal de la grille dans un conteneur, ou rÃ©duire la taille des cellules et afficher une grille compressÃ©e. Une option intÃ©ressante est de passer en mode â€œcarteâ€ sur mobile : afficher chaque pÃ©riode lâ€™une en dessous de lâ€™autre, ou un carrousel par bloc. NÃ©anmoins, cela casse la reprÃ©sentation classique. Il est sans doute prÃ©fÃ©rable de garder la reprÃ©sentation standard et de la rendre scrollable (lâ€™utilisateur balaie pour voir les groupes Ã  droite). On utilisera Tailwind CSS pour crÃ©er une grille flexible (par ex. grid-cols-18 sur desktop, et peut-Ãªtre grid-cols-7 sur mobile avec des sauts de ligne pour groupes, etc.). On devra ajuster la taille du texte et des marges pour que chaque case reste cliquable au doigt (taille min ~40px).
Tablettes (~768px - 1024px) : Ici, on peut peut-Ãªtre afficher la table entiÃ¨re si chaque case est plus petite, ou prÃ©voir un lÃ©ger scroll. On vÃ©rifiera que les labels (numÃ©ro, symbole, nom Ã©ventuellement) restent visibles. Sur tablette, la fiche Ã©lÃ©ment pourrait sâ€™afficher en overlay Ã  cÃ´tÃ© du tableau si lâ€™orientation est paysage.
Desktop grand Ã©cran : Veiller Ã  ce que le tableau ne â€œnageâ€ pas dans un Ã©cran ultra large non plus. On peut centrer le contenu et fixer une largeur max pour le tableau (par ex. limiter Ã  ~1200px de large pour le tableau lui-mÃªme, sinon les espaces entre Ã©lÃ©ments deviennent trop grands).
Tests multi-navigateurs : On sâ€™assurera du rendu sur Chrome, Firefox, Safari, Edge, ainsi que sur WebView mobile (Chrome Android, Safari iOS). Svelte gÃ©nÃ¨re du code largement compatible ES5+, donc Ã§a devrait fonctionner partout sauf IE (public peu pertinent en 2025). Tailwind et GSAP sont aussi compatibles cross-browser. Attention toutefois aux API CSS utilisÃ©es (grid, flex, etc. sont bien supportÃ©s maintenant).
Internationalisation (i18n) : Techniquement, dÃ¨s le dÃ©part, on structurera le projet pour supporter plusieurs langues :
On aura par exemple un dossier src/i18n/ avec des fichiers JSON ou JS pour les textes : fr.json et en.json. Dedans, on stocke les traductions de toutes les chaÃ®nes utilisÃ©es dans lâ€™UI (libellÃ©s de boutons, titres de sections, texte de lâ€™anecdote, etc.) par clÃ©s.
Pour le contenu des Ã©lÃ©ments, deux approches : soit on intÃ¨gre dÃ¨s le JSON des Ã©lÃ©ments les diffÃ©rentes langues (ex: name_fr, description_fr, etc.), soit on maintient deux fichiers de donnÃ©es parallÃ¨les (moins DRY). Mieux vaut enrichir la structure JSON initiale pour inclure les noms franÃ§ais des Ã©lÃ©ments par exemple. On peut Ã©galement prÃ©voir que lâ€™anecdote soit diffÃ©rente en fonction de la culture (une blague peut nÃ©cessiter adaptation).
Utilisation : dans Svelte, on pourra crÃ©er un store currentLang et un helper $t(key) qui va chercher la chaÃ®ne correspondante. Il existe des librairies comme svelte-i18n qui peuvent aider Ã  charger les dictionnaires et fournir un $_ (translator function). On doit veiller Ã  ce que le basculement de langue rafraÃ®chisse bien tous les textes affichÃ©s (Svelte re-rendra si le store de langue change).
Au niveau de lâ€™URL, on pourrait coder la langue, ex. /fr/element/Fe vs /en/element/Fe. Mais Ã§a complique le routage sans SvelteKit. On peut plutÃ´t gÃ©rer la langue en interne (ex: stocker le choix en localStorage ou dans lâ€™URL query ?lang=en). Pour la premiÃ¨re version, un simple toggle dans lâ€™UI suffira.
Contenu non traduit : tant que la version anglaise du contenu dÃ©taillÃ© nâ€™est pas prÃªte, il faudra dÃ©cider : afficher le contenu FR mÃªme si lâ€™UI est en anglais (avec un petit message â€œcontent available in French only pour lâ€™instantâ€), ou bien masquer les textes non traduits. Il serait idÃ©al dâ€™au moins fournir les noms dâ€™Ã©lÃ©ments en anglais si UI en anglais, pour consistance.
Enfin, il faudra tester le formatage (par ex. les nombres dÃ©cimaux virgule vs point, unitÃ©s) selon la locale, bien que la plupart des donnÃ©es chimiques seront des constantes identiques entre langues (sauf le nom de lâ€™unitÃ©, ex â€œg/cmÂ³â€ reste pareil).
Performance et optimisation :
Lâ€™application doit Ãªtre rapide Ã  charger et rÃ©active. Svelte aide beaucoup car câ€™est un framework sans virtual DOM, qui gÃ©nÃ¨re du JS optimisÃ© et met Ã  jour le DOM de faÃ§on trÃ¨s ciblÃ©eâ€‹
svelte.dev
. De plus, Svelte nâ€™embarque quâ€™un runtime minimal, ce qui rÃ©duit la taille du bundle. On exploitera ces atouts.
On fera attention au poids des assets : le JSON des Ã©lÃ©ments peut Ãªtre volumineux (~100 KB peut-Ãªtre). On pourrait le charger de maniÃ¨re asynchrone aprÃ¨s lâ€™affichage initial (ex: afficher la table vide puis remplir, mais ce nâ€™est pas idÃ©al visuellement). Comme il sâ€™agit dâ€™une SPA, on peut aussi inclure le JSON dans le bundle directement (via un import, webpack/vite va lâ€™intÃ©grer). Il faudra mesurer ce qui est mieux. Si on inclut GSAP, câ€™est ~50 KB minifiÃ©s; Tailwind CSS purge les classes non utilisÃ©es donc le CSS final sera optimisÃ©.
Les images/illustrations doivent Ãªtre lÃ©gÃ¨res : si on dÃ©cide dâ€™avoir une icÃ´ne par Ã©lÃ©ment, on utilisera soit une police dâ€™icÃ´nes SVG (trÃ¨s lÃ©ger) soit des petites images compressÃ©es. Tout ce qui est mÃ¨me/emoji peut souvent Ãªtre fait en Unicode ou CSS (ex: âš›ï¸ pour lâ€™atome).
RafraÃ®chissements : Svelte rendra le composant global en une fois. Il y aura potentiellement 118 sous-composants (chaque case). Il faut sâ€™assurer que mettre Ã  jour un Ã©tat (ex: activer un filtre) ne va pas refaire un DOM diff Ã©norme. IdÃ©alement, chaque case peut avoir une classe liÃ©e aux filtres, et Svelte peut mettre Ã  jour seulement les cases concernÃ©es. 118 nâ€™est pas un grand nombre, donc mÃªme un re-render total reste envisageable (peu de coÃ»t).
Animations : Utiliser GSAP nÃ©cessite dâ€™animer en JS. Il faudra veiller Ã  ne pas bloquer le thread principal. On utilisera requestAnimationFrame via GSAP qui est bien optimisÃ©. On Ã©vitera les animations de trop longue durÃ©e simultanÃ©es. Aussi, stopper/nettoyer les animations quand on quitte une page (ex: si on navigue alors quâ€™une animation est en cours).
Lazy loading : Si certaines parties du site sont lourdes et pas immÃ©diatement utiles, on pourrait les charger Ã  la demande. Par exemple, si on avait une section â€œvidÃ©o explicativeâ€ intÃ©grÃ©e (YouTube), on ne la chargerait quâ€™au clic. Ou si on intÃ©grait les modÃ¨les 3D de Bohr (le JSON Bowserinator mentionne des liens glTF pour chaque Ã©lÃ©ment), on ne chargerait ces modÃ¨les que si lâ€™utilisateur choisit de les voir. Bref, charger progressivement pour ne pas impacter la performance initiale.
Profiling : On fera des tests de performance (Lighthouse, etc.) pour sâ€™assurer que le site obtient de bons scores (notamment sur mobile). Lâ€™objectif est que le site se charge en quelques secondes mÃªme en 3G, et que toutes les interactions soient fluides.
AccessibilitÃ© : En plus dâ€™Ãªtre responsive, le site doit Ãªtre utilisable par le plus grand nombre, y compris avec des aides techniques :
On ajoutera des attributs ARIA pertinents : role="table" pour la grille, role="button" + aria-label sur chaque case (ex: <div role="button" aria-label="HydrogÃ¨ne, Ã©lÃ©ment 1">H</div>), ainsi une lecture dâ€™Ã©cran pourra Ã©noncer lâ€™Ã©lÃ©ment sous le focus.
NavigabilitÃ© clavier : sâ€™assurer quâ€™on peut tabuler Ã  travers les Ã©lÃ©ments du tableau (peut-Ãªtre faire un focus loop spÃ©cifique, ou utiliser les flÃ¨ches pour naviguer comme un vÃ©ritable tableau, ce serait top en UX avancÃ©e). Ã€ minima, tab doit aller sur la grille, puis permettre dâ€™entrer dans la grille.
Contrastes de couleurs : respecter les ratios AA ou AAA pour le texte sur fond colorÃ© (les personnes daltoniennes doivent pouvoir distinguer les catÃ©gories, donc peut-Ãªtre ajouter un motif ou un symbole en plus de la couleur pour indiquer un groupe).
PrÃ©voir une fallback si JS dÃ©sactivÃ© : probablement le site ne fonctionnera pas (Ã©tant une SPA), mais on peut quand mÃªme mettre un message invitant Ã  activer JS. On pourrait offrir une version statique minimale du tableau (par ex. un lien vers une image PNG du tableau pÃ©riodique) en dernier recours.
MaintenabilitÃ© et Ã©volutivitÃ© : Au-delÃ  des contraintes immÃ©diates, on code de maniÃ¨re Ã  pouvoir faire Ã©voluer le site. Par exemple, lâ€™architecture i18n doit permettre dâ€™ajouter une langue supplÃ©mentaire facilement. La structure des donnÃ©es doit accepter dâ€™ajouter un champ (imaginons quâ€™on veuille rajouter â€œdÃ©couverteâ€ ou â€œÃ©tat de la matiÃ¨re Ã  0Kâ€ plus tard). Respecter les principes SOLID/DRY (dÃ©taillÃ©s en partie 8) est aussi une contrainte technique pour garder un code propre. On documentera le code pour que dâ€™autres dÃ©veloppeurs ou nous-mÃªme dans 6 mois puissions sâ€™y replonger sans peine.
SÃ©curitÃ© et fiabilitÃ© : MÃªme si câ€™est une appli front sans donnÃ©es sensibles, on fera attention aux Ã©ventuels contenus externes. Par exemple, si on intÃ¨gre des extraits de Wikipedia, on veillera Ã  filtrer ce qui pourrait Ãªtre malveillant (script). Mais comme on passera par un JSON maÃ®trisÃ©, Ã§a devrait aller. On sâ€™assurera aussi de bien gÃ©rer les erreurs (si un Ã©lÃ©ment nâ€™a pas de donnÃ©es dispo, afficher â€œinfo non disponibleâ€ plutÃ´t quâ€™une page blanche). Testez les cas limites : ex. accÃ©der Ã  /element/XYZ avec XYZ inexistant doit renvoyer vers la page dâ€™accueil ou montrer un message dâ€™erreur clair.
En respectant ces contraintes techniques, on sâ€™assure que le site ne sera pas seulement attractif, mais aussi robuste et accessible dans la pratique, quelles que soient les conditions dâ€™utilisation (appareil, langue, contexte rÃ©seau). La rÃ©ussite du projet dÃ©pend autant de ces dÃ©tails techniques que des fonctionnalitÃ©s visibles.
8. RÃ¨gles de dÃ©veloppement du projet (SOLID, DRY, code modulaireâ€¦)
Pour garantir la qualitÃ© du code et la facilitÃ© de maintenance, le projet suivra un ensemble de rÃ¨gles et bonnes pratiques de dÃ©veloppement, adaptÃ©es Ã  Svelte et aux principes gÃ©nÃ©raux (SOLID, DRY, etc.) :
Organisation modulaire du code : On divisera le projet en composants Svelte et modules de fonction distincts, chacun ayant une responsabilitÃ© claire (Single Responsibility Principle du SOLID). Par exemple, un composant ElementCard.svelte ne fera que lâ€™affichage dâ€™une case Ã©lÃ©ment dans la grille, un composant ElementModal.svelte gÃ©rera lâ€™affichage des dÃ©tails dâ€™un Ã©lÃ©ment, un module dataService.ts sera responsable de charger/fournir les donnÃ©es des Ã©lÃ©ments. Cette sÃ©paration rend le code plus lisible et facilite les tests/unitaires Ã©ventuels.
DRY (Donâ€™t Repeat Yourself) : Ã‰viter la duplication de code ou de logique. Sâ€™il y a des styles redondants, on les factorise via Tailwind (en utilisant des classes utilitaires rÃ©utilisables ou des composants). Sâ€™il y a des valeurs constantes utilisÃ©es Ã  plusieurs endroits (par ex. liste des catÃ©gories dâ€™Ã©lÃ©ments, ou palette de couleurs), on les dÃ©finira une fois (dans un fichier de config). Par exemple, la logique de filtrage peut Ãªtre centralisÃ©e : au lieu de coder dans 5 endroits la condition â€œsi Ã©lÃ©ment.category == filtreâ€, on crÃ©e une fonction utilitaire filterElements(elements, criteria) quâ€™on rÃ©utilise. De mÃªme pour formater une unitÃ© ou trier par numÃ©ro. Le but est de minimiser les sources dâ€™erreur et de simplifier les modifications futures (changer une rÃ¨gle de filtre dans une fonction unique plutÃ´t que traquer 5 duplications).
Nommage clair et cohÃ©rence : Les variables, fonctions et composants auront des noms explicites, en anglais dans le code (convention de dev, par ex. currentElement, openModal(), etc.). On utilisera une convention de casse cohÃ©rente (camelCase pour variables/fonctions JS, PascalCase pour composants Svelte, SCREAMING_SNAKE_CASE pour constantes globales). Les fichiers seront organisÃ©s par fonctionnalitÃ© (par ex. un dossier components/ avec sous-dossiers Table/, ElementDetails/, etc., un dossier data/ pour les fichiers JSON ou TS de donnÃ©es). Cette structuration aide Ã  sâ€™y retrouver dans le projet.
Principe dâ€™Ouvert/FermÃ© (SOLID) : Le code est conÃ§u pour Ãªtre ouvert Ã  lâ€™extension mais fermÃ© Ã  la modification. En pratique, cela signifie quâ€™on prÃ©fÃ¨re ajouter de nouvelles instances ou donnÃ©es plutÃ´t que modifier le code existant pour changer un comportement. Par exemple, si on veut ajouter un troisiÃ¨me langage plus tard, on ne doit pas avoir Ã  rÃ©Ã©crire toute la logique dâ€™i18n â€“ il suffira dâ€™ajouter un fichier de langues. Cela implique dâ€™anticiper un peu : on paramÃ©trera les textes via des clÃ©s et non en dur, on utilisera des structures de donnÃ©es (objets, tableaux) quâ€™on peut allonger. De mÃªme, pour les filtres, on pourrait stocker la dÃ©finition des filtres dans un tableau dâ€™objets (nom, fonction de critÃ¨re) et boucler dessus pour gÃ©nÃ©rer les boutons. Ainsi, ajouter un nouveau filtre revient Ã  ajouter un objet dans ce tableau, pas Ã  coder un nouveau if ailleurs. Cette approche modulaire et extensible Ã©vite dâ€™introduire des bugs en modifiant le cÅ“ur du code.
Utilisation judicieuse de TypeScript : TypeScript nous aide Ã  respecter lâ€™interface des donnÃ©es et Ã  attraper des erreurs tÃ´t. On dÃ©finira des interfaces/types clairs, par ex. interface ElementData { number: number; symbol: string; name_fr: string; name_en: string; category: string; â€¦ }. Ces types seront utilisÃ©s partout (les composants ElementDetails attendront une prop de type ElementData par exemple). Cela rejoint le principe dâ€™Interface Segregation (SOLID) : on crÃ©e des types prÃ©cis pour chaque besoin plutÃ´t quâ€™une mÃ©ga-interface fourre-tout. Par exemple, on peut avoir un type ElementBasicInfo pour la liste (juste symbole, numÃ©ro, catÃ©gorie pour colorer) et un type ElementFullInfo avec tous les champs pour la fiche. Chaque fonction nâ€™utilisera que le type dont elle a besoin, ainsi on limite les dÃ©pendances et on clarifie les contrats.
Gestion de lâ€™Ã©tat global vs local : On profitera du systÃ¨me rÃ©actif de Svelte. Pour lâ€™Ã©tat global (langue courante, filtres actifs, Ã©ventuellement lâ€™Ã©lÃ©ment sÃ©lectionnÃ© si on gÃ¨re en contexte global), on utilisera les Svelte stores. Par exemple un store currentFilters (readable/writable) accessible Ã  la fois par le composant Filtres et par le composant Tableau pour savoir quoi afficher. Idem pour currentLang. Lâ€™utilisation de stores dÃ©couplÃ©s permet de ne pas lier trop fortement les composants entre eux (principe dâ€™Inversion de DÃ©pendance : les composants dÃ©pendent dâ€™abstractions â€“ ici le store â€“ plutÃ´t que directement les uns des autres). Pour lâ€™Ã©tat purement local (ex: si un sous-composant a son toggling interne), on utilisera le setContext/getContext de Svelte ou des props classiques. On fera en sorte quâ€™un composant reÃ§oit en props tout ce dont il a besoin, au lieu dâ€™aller piocher globalement nâ€™importe oÃ¹ â€“ cela le rend plus rÃ©utilisable et testable en isolation.
Commentaires et documentation : MÃªme si le code est en principe clair, on ajoutera des commentaires pour les parties non triviales. Par exemple, une fonction complexe de calcul (mettons, dÃ©terminer tous les Ã©lÃ©ments radioactifs) sera commentÃ©e en en-tÃªte pour expliquer lâ€™algorithme ou la source de la rÃ¨gle. On documentera aussi les composants (quelles props ils acceptent, quels events ils Ã©mettent). Ceci suit le principe de lisibilitÃ© du code : un autre dÃ©veloppeur (ou lâ€™AI pair programmer comme Cursor) doit comprendre lâ€™intention sans effort. On peut gÃ©nÃ©rer un petit README technique du projet qui rappelle les conventions, lâ€™arborescence, comment ajouter un Ã©lÃ©ment ou une langueâ€¦
Respect des principes SOLID dans la mesure du possible : MÃªme si SOLID est originellement formulÃ© pour la POO, on peut en appliquer lâ€™esprit :
Single Responsibility : dÃ©jÃ  abordÃ© (un module = une tÃ¢che).
Open/Closed : anticiper lâ€™extension sans modif massive.
Liskov Substitution : sâ€™applique moins ici, mais par exemple si on a une classe ou fonction gÃ©nÃ©rique, toute spÃ©cialisation doit pouvoir la remplacer sans casse. ConcrÃ¨tement, si on avait plusieurs types de tableau (un complet vs un simplifiÃ©), ils devraient offrir la mÃªme interface dâ€™utilisation.
Interface Segregation : dÃ©jÃ  mentionnÃ© avec TS types â€“ Ã©viter les â€œgod objectsâ€.
Dependency Inversion : dÃ©coupler modules hauts niveaux et bas niveaux. Par ex, le composant UI de tableau nâ€™accÃ©dera pas directement Ã  fetch(url) pour les donnÃ©es, il appellera un service de donnÃ©es. Ainsi, si on change la source (JSON local vers API), on modifie le service mais pas le composant UI. On ... - Dependency Inversion : On Ã©vitera que les composants de haut niveau dÃ©pendent directement de modules de bas niveau concrets. On introduira des abstractions (interfaces ou fonctions intermÃ©diaires) pour dÃ©coupler. Par exemple, le composant qui affiche les dÃ©tails dâ€™un Ã©lÃ©ment ne lira pas lui-mÃªme dans le JSON, il fera appel Ã  un service de donnÃ©es (fetchElementData(id) dans un module sÃ©parÃ©). Ainsi, si lâ€™on change la source des donnÃ©es (passer dâ€™un JSON local Ã  une API externe), on nâ€™aura quâ€™Ã  modifier le service de donnÃ©es, sans toucher aux composants UI. Cela rend le systÃ¨me plus modulable et testable (on peut mock le service en tests).
Maintenir la propretÃ© du code : On suivra les standards de dÃ©veloppement recommandÃ©s dans lâ€™Ã©diteur (par ex. Cursor) : formattage automatique (Prettier), linting (ESLint) pour attraper les incohÃ©rences, structure de fichiers logique. Chaque composant Svelte sera dans son fichier dÃ©diÃ©, et on Ã©vitera les fichiers trop longs (>300 lignes) en subdivisant si nÃ©cessaire. On versionnera le code avec Git en faisant des commits atomiques et bien commentÃ©s (une fonctionnalitÃ© ou correction par commit). Cela facilite les revues et le suivi de lâ€™historique.
Commentaires et documentation du projet : MÃªme si lâ€™on souhaite que le code soit auto-explicatif, on ajoutera des commentaires lÃ  oÃ¹ câ€™est utile (logique complexe, hacks nÃ©cessaires, TODO futurs). On peut utiliser la syntaxe JSDoc pour documenter les fonctions TS importantes. Une documentation Markdown (README) du projet expliquera comment le code est organisÃ©, comment ajouter un Ã©lÃ©ment ou une langue, quelles conventions suivre â€“ cela aidera tout nouveau contributeur ou lâ€™IA dâ€™aide au codage (Cursor) Ã  comprendre le contexte.
En appliquant ces principes (SOLID, DRY) et bonnes pratiques, on sâ€™assure que le code du projet sera modulaire, lisible et facile Ã  maintenir sur le long terme. Cela permettra dâ€™accueillir sereinement de nouvelles fonctionnalitÃ©s ou contributions, tout en minimisant les bugs. Le dÃ©veloppement sera plus efficace et fiable, lâ€™outil Cursor pouvant dâ€™ailleurs mieux assister sur un code bien structurÃ©. En somme, ces rÃ¨gles garantissent une base de code saine pour notre application de tableau pÃ©riodique interactive, au bÃ©nÃ©fice des dÃ©veloppeurs comme des utilisateurs finaux.
Plan de conception du site web interactif du tableau pÃ©riodique
1. Analyse des solutions existantes (design, UX, contenu)
Pour orienter la conception, il est utile dâ€™examiner les meilleurs sites et applications actuels prÃ©sentant le tableau pÃ©riodique. Voici quelques exemples remarquables, avec leurs points forts en termes de design, dâ€™expÃ©rience utilisateur (UX) et de contenuÂ :
Ptable.com â€“ Un site trÃ¨s complet et interactif. Il propose une multitude de fonctionnalitÃ©s dynamiques : visualisation des tendances de propriÃ©tÃ©s, milliers dâ€™isotopes, mÃ©lange de composÃ©s, orbitales 3D, etcâ€‹
ptable.com
. Lâ€™interface est riche en donnÃ©es (points de fusion/Ã©bullition, Ã©lectrons par couche, etc.), avec un mode sombre et des options dâ€™affichage. Une barre de recherche permet de trouver un Ã©lÃ©ment par nom, numÃ©ro ou mÃªme par valeur de propriÃ©tÃ©â€‹
ptable.com
. Ptable est disponible en plusieurs langues dont le franÃ§aisâ€‹
ptable.com
, ce qui Ã©largit son audience. En revanche, cette richesse peut surcharger lâ€™utilisateur non expert par la quantitÃ© dâ€™informations affichÃ©es.
Tableau pÃ©riodique interactif de la RSC â€“ La Royal Society of Chemistry propose un site trÃ¨s riche en contenu multimÃ©dia. Chaque Ã©lÃ©ment est accompagnÃ© dâ€™informations dÃ©taillÃ©es (histoire de la dÃ©couverte, usages, propriÃ©tÃ©s) et de contenus ludiques : onglets pour lâ€™histoire, lâ€™alchimie, des podcasts audio, des vidÃ©os, ainsi que des graphiques de tendancesâ€‹
periodic-table.rsc.org
. Une Å“uvre visuelle unique illustre chaque Ã©lÃ©ment (projet â€œVisual Elementsâ€ de Murray Robertson). Le design est sobre et scientifique, avec un code couleur par catÃ©gorie dâ€™Ã©lÃ©ment. Lâ€™UX encourage lâ€™exploration : on peut cliquer sur un Ã©lÃ©ment pour voir sa fiche complÃ¨te, ou parcourir des onglets thÃ©matiques pour dÃ©couvrir des anecdotes historiques. Ce site offre Ã©normÃ©ment dâ€™informations, mais le ton reste assez sÃ©rieux et acadÃ©mique â€“ lâ€™aspect Â« fun Â» est moins prononcÃ© (peu dâ€™anecdotes amusantes ou de mÃ¨mes). De plus, lâ€™interface est chargÃ©e et peut Ãªtre moins adaptÃ©e aux petits Ã©crans.
Fisher Scientific â€“ Interactive Periodic Table â€“ Un exemple moderne dâ€™UX Ã©purÃ©e au service de lâ€™efficacitÃ©. Ce tableau pÃ©riodique interactif de Fisher Scientific prÃ©sente les Ã©lÃ©ments avec leurs propriÃ©tÃ©s principales et utilise un code couleur classique (mÃ©taux, non-mÃ©taux, etc.)â€‹
fishersci.com
. Son point fort rÃ©side dans les filtres faciles Ã  utiliser : lâ€™utilisateur peut filtrer les Ã©lÃ©ments par nature (mÃ©taux vs non-mÃ©taux), par Ã©tat physique (solide/liquide/gaz), par groupe, par pÃ©riode, etc.â€‹
fishersci.com
. Cette fonctionnalitÃ© de tri permet de mettre en Ã©vidence des sous-ensembles (par ex. tous les gaz nobles ou les Ã©lÃ©ments radioactifs). Un clic sur un Ã©lÃ©ment affiche un pop-up avec les propriÃ©tÃ©s essentielles (numÃ©ro atomique, masse, etc.). Le design est rÃ©actif et adaptÃ© aux usages professionnels (Ã©ducateurs, scientifiques) mais reste trÃ¨s sobre visuellement (peu dâ€™illustrations ludiques).
Chemicool.com â€“ Un portail Ã©ducatif plus traditionnel, connu pour son approche conviviale et pÃ©dagogique. Le site se dÃ©crit comme un Â« tableau pÃ©riodique primÃ©, avec des donnÃ©es et faits conviviaux Â», incluant Ã©galement des vidÃ©os de chimie, un dictionnaire, des outils et un forumâ€‹
morefunz.com
. Chaque Ã©lÃ©ment a une fiche descriptive avec des faits intÃ©ressants et des donnÃ©es de base. Le design est simple (tableau HTML classique) et commence Ã  dater, mais lâ€™information est prÃ©sentÃ©e de maniÃ¨re accessible. Lâ€™accent est mis sur les Â« cool facts Â» (faits marquants) pour captiver les Ã©tudiants. ComparÃ© Ã  Ptable ou RSC, Chemicool est moins interactif (pas de visualisation dynamique ni de filtres), mais son ton didactique et clair est apprÃ©ciÃ© des dÃ©butants.
Tableau pÃ©riodique illustrÃ© en images â€“ 

Exemple dâ€™un tableau pÃ©riodique ludique et visuel. Une approche notable est celle de Keith Enevoldsen avec son â€œPeriodic Table in Pictures and Wordsâ€â€‹
elements.wlonk.com
. Ce tableau pÃ©riodique pictural est trÃ¨s colorÃ©, fun et informatif. Chaque case dâ€™Ã©lÃ©ment comporte un dessin illustrant un usage principal ou un aspect marquant de lâ€™Ã©lÃ©ment, en plus du nom, symbole et numÃ©ro atomiqueâ€‹
elements.wlonk.com
. Des icÃ´nes supplÃ©mentaires indiquent des infos clÃ©s (Ã©tat Ã  tempÃ©rature ambiante, prÃ©sence dans le corps humain, raretÃ© naturelle, radioactivitÃ©, etc.)â€‹
elements.wlonk.com
. Le code couleur montre les familles chimiques, avec une lÃ©gende claire. Cette approche rend le tableau attractif pour un public jeune sans lâ€™alourdir de chiffres complexes (les donnÃ©es techniques comme la masse atomique ne sont pas mises en avant)â€‹
elements.wlonk.com
. Il existe mÃªme une version interactive en ligne, avec du texte explicatif Ã  la place des images pour dÃ©tailler usages et occurrences naturelles. Ce type de design est trÃ¨s pertinent pour vulgariser la chimie auprÃ¨s du grand public.
En rÃ©sumÃ©, les solutions existantes montrent une diversitÃ© dâ€™approches : dâ€™un cÃ´tÃ© des outils complets pour experts (ptable, RSC) riches en donnÃ©es, de lâ€™autre des versions simplifiÃ©es ou ludiques pour les Ã©tudiants et curieux (Chemicool, tableaux illustrÃ©s). Peu de sites combinent rigueur scientifique et ton amusant. Notre dÃ©fi sera de trouver un Ã©quilibre, en sâ€™inspirant des points forts de chacun (interactivitÃ©, filtres, anecdotes, visuels) tout en restant accessible et attrayant pour tous.
2. Lacunes des sites actuels et axes dâ€™amÃ©lioration
En analysant ces ressources, on peut identifier plusieurs manques ou pistes dâ€™amÃ©lioration pour notre propre projetÂ :
Manque de ton ludique et dâ€™anecdotes : La plupart des sites adoptent un ton soit trÃ¨s acadÃ©mique (RSC, Fisher) soit trÃ¨s Ã©ducatif sÃ©rieux. Ils fournissent des faits et des donnÃ©es, mais intÃ¨grent rarement des anecdotes scientifiques amusantes ou de lâ€™humour. Aucun nâ€™utilise par exemple de mÃ¨mes ou de clins dâ€™Å“il culturels pour marquer les esprits. Cette dimension Â«Â funÂ Â» est une opportunitÃ© pour dÃ©marquer notre site, sans sacrifier la prÃ©cision scientifique.
Design parfois datÃ© ou trop austÃ¨re : Certains tableaux pÃ©riodiques en ligne ont une interface assez statique ou peu moderne (Chemicool, sites Ã©ducatifs classiques). MÃªme des projets plus rÃ©cents reconnaissent que les concurrents ont souvent des faiblesses de design et de structure de donnÃ©esâ€‹
competition.adesignaward.com
. Il y a donc place pour une UX plus soignÃ©e et contemporaine : interface Ã©purÃ©e, typographie moderne, mises en page aÃ©rÃ©e, et pourquoi pas des illustrations lÃ©gÃ¨res pour chaque Ã©lÃ©ment. Un design plus attrayant visuellement permettra de toucher un public plus large, y compris les plus jeunes qui attendent une certaine esthÃ©tique moderne.
Surcharge dâ€™information vs. concision : Ã€ lâ€™opposÃ©, des sites comme Ptable ou RSC, bien que trÃ¨s complets, peuvent submerger lâ€™utilisateur sous une avalanche de chiffres et de propriÃ©tÃ©s techniques. Un utilisateur curieux Â« tout public Â» risque de sâ€™y perdre ou de dÃ©crocher face Ã  trop de dÃ©tails dâ€™un coup. Il manque souvent une prÃ©sentation hiÃ©rarchisÃ©e de lâ€™information : dâ€™abord une courte description accessible, puis des dÃ©tails supplÃ©mentaires seulement si on le souhaite. Notre site visera Ã  afficher lâ€™essentiel de faÃ§on synthÃ©tique (quelques phrases, usages clÃ©s) avec la possibilitÃ© dâ€™Ã©tendre pour les dÃ©tails (approche progressive).
Peu dâ€™ancrage pratique (usages) : Hormis quelques exceptions (par ex. le tableau illustrÃ© de Enevoldsen qui montre un usage par imageâ€‹
elements.wlonk.com
), beaucoup de prÃ©sentations se concentrent sur les propriÃ©tÃ©s chimiques/physiques et lâ€™histoire. Les usages concrets des Ã©lÃ©ments au quotidien ne sont pas toujours mis en avant. Notre projet prÃ©voit pour chaque Ã©lÃ©ment 2â€“3 usages typiques immÃ©diatement visibles, ce qui manque sur des sites comme Ptable (oÃ¹ il faut lire un long texte Wikipedia pour trouver les applications). Mettre en avant ces usages rendra la chimie plus tangible pour lâ€™utilisateur moyen.
Filtrage et recherche parfois limitÃ©s : Tous les sites nâ€™offrent pas des fonctions de recherche sophistiquÃ©es. Certains nâ€™ont pas de barre de recherche par nom/symbole et comptent sur la connaissance de la position de lâ€™Ã©lÃ©ment dans la table. De mÃªme, les filtres par propriÃ©tÃ© ne sont pas systÃ©matiques. Fisher Scientific propose bien des filtres par mÃ©tal/non-mÃ©tal, Ã©tat, etcâ€‹
fishersci.com
, mais peu dâ€™autres le font de maniÃ¨re aussi accessible. Par exemple, filtrer par radioactivitÃ© (montrer uniquement les Ã©lÃ©ments sans isotopes stables) est rare alors que câ€™est pertinent pour le public. IntÃ©grer une recherche instantanÃ©e (auto-complÃ©tion par nom ou symbole) et des filtres variÃ©s (catÃ©gorie, Ã©tat, radioactifs, abondance, etc.) amÃ©liorerait lâ€™expÃ©rience.
AccessibilitÃ© linguistique : La majoritÃ© des ressources en ligne sont en anglais. Ptable fait figure dâ€™exception en proposant une interface multilingue (par exemple, nom des Ã©lÃ©ments traduits en franÃ§ais comme HydrogÃ¨neâ€‹
ptable.com
), ce qui montre quâ€™il existe une demande pour ce type de contenu en diffÃ©rentes langues. Offrir dÃ¨s le dÃ©part une internationalisation (au moins franÃ§ais/anglais) sera un avantage Ã©norme pour toucher le public francophone et anglophone. Peu dâ€™applications actuelles lâ€™intÃ¨grent nativement.
Optimisation mobile : Certaines reprÃ©sentations du tableau pÃ©riodique ne sâ€™adaptent pas bien aux Ã©crans mobiles en raison du grand nombre de colonnes. Parfois, câ€™est une simple image fixe non zoomable, ou bien une version trÃ¨s rÃ©duite illisible sans zoom manuel. Il manque souvent un design responsive innovant pour mobile (par exemple, un mode liste ou un dÃ©filement tactile intuitif pour naviguer dans le tableau). Câ€™est un aspect Ã  soigner, car beaucoup dâ€™utilisateurs pourraient consulter le site depuis une tablette ou un smartphone.
FonctionnalitÃ©s inÃ©dites : Dâ€™aprÃ¨s des retours de concepteurs, il reste des fonctionnalitÃ©s peu rÃ©pandues qui pourraient enrichir lâ€™expÃ©rience. Par exemple, quasiment aucun service existant nâ€™intÃ¨gre un rÃ©fÃ©rentiel de rÃ©actions chimiques impliquant les Ã©lÃ©ments (cette idÃ©e a Ã©tÃ© soulignÃ©e comme une innovation majeure dans un projet primÃ©â€‹
competition.adesignaward.com
). Sans aller forcÃ©ment jusque-lÃ  pour une v1, garder Ã  lâ€™esprit de futures extensions (module sur les composÃ©s courants de chaque Ã©lÃ©ment, rÃ©actions cÃ©lÃ¨bres, etc.) pourrait distinguer notre application Ã  long terme.
En synthÃ¨se, notre projet cherchera Ã  combler ces lacunes : offrir un contenu scientifique fiable mais prÃ©sentÃ© de faÃ§on attractive et amusante, hiÃ©rarchiser lâ€™information avec des anecdotes et usages concrets, proposer une interface moderne avec recherche/filtre puissants, adaptÃ©e au mobile, et accessible en deux langues. Cela rÃ©pondra aux besoins dâ€™un public curieux qui nâ€™est pas forcÃ©ment chimiste, en lui donnant un outil Ã  la fois instructif et plaisant Ã  explorer.
3. Sources de donnÃ©es chimiques (API et jeux de donnÃ©es publics fiables)
Pour alimenter le site en informations sur les Ã©lÃ©ments, il est crucial dâ€™utiliser des sources de donnÃ©es fiables et Ã  jour. Plusieurs options de datasets ou APIs publics existent pour obtenir les propriÃ©tÃ©s des Ã©lÃ©ments chimiquesÂ :
Fichier JSON open-source (Bowserinator/Periodic-Table-JSON) â€“ Câ€™est un projet GitHub qui fournit un JSON complet de tous les Ã©lÃ©ments. Il compile des donnÃ©es provenant notamment de Wikipedia et autres sources pour chaque Ã©lÃ©ment. Notablement, â€œtous les Ã©lÃ©ments ont un rÃ©sumÃ© de trois phrases issu de WikipÃ©diaâ€â€‹
github.com
, ce qui correspond exactement au format souhaitÃ© pour notre courte description. Le JSON contient Ã©galement de nombreuses propriÃ©tÃ©s (points dâ€™Ã©bullition en K, densitÃ©, configuration Ã©lectronique, etc.), avec les valeurs manquantes indiquÃ©es par nullâ€‹
github.com
. Pour chaque Ã©lÃ©ment, une clÃ© "source" donne le lien vers la source dâ€™information originaleâ€‹
github.com
, assurant la traÃ§abilitÃ© des donnÃ©es. Ce dataset a lâ€™avantage dâ€™Ãªtre statique, donc intÃ©grable directement dans notre application (pas de dÃ©pendance Ã  un service externe une fois le fichier inclus). Il faudra toutefois filtrer les informations pertinentes pour ne pas surcharger lâ€™utilisateur (on nâ€™affichera pas tout). Ã‰tant basÃ© sur Wikipedia, il est assez fiable et peut Ãªtre mis Ã  jour facilement si nÃ©cessaire.
API REST en ligne (ex. Heroku/Postman) â€“ Il existe des APIs publiques qui renvoient les donnÃ©es des Ã©lÃ©ments en JSON via des requÃªtes HTTP. Par exemple, une API dÃ©ployÃ©e sur Heroku (documentÃ©e sur Postman) permet de rÃ©cupÃ©rer les donnÃ©es dâ€™un Ã©lÃ©ment par son nom, symbole ou numÃ©ro. Ce type dâ€™API renvoie les propriÃ©tÃ©s essentielles (numÃ©ro atomique, masse atomique, point de fusion, etc.) et peut convenir si lâ€™on veut charger les donnÃ©es Ã  la volÃ©e. Cependant, dÃ©pendre dâ€™une API tierce implique une connexion internet et un risque de latence ou dâ€™indisponibilitÃ©. Pour un site purement front-end Svelte, embarquer un JSON local peut Ãªtre plus robuste. On peut nÃ©anmoins sâ€™inspirer de ces APIs pour la structure des donnÃ©es. Par exemple, lâ€™API Periodic Table sur RapidAPI agrÃ¨ge des informations issues de sources faisant autoritÃ© en chimieâ€‹
rapidapi.com
 â€“ garantissant la fiabilitÃ© des donnÃ©es â€“ mais son usage requiert sans doute une clÃ© et entraÃ®ne des appels rÃ©seaux.
Packages de donnÃ©es (NPM, Python) â€“ Le projet Exabyte-io/periodic-table propose un package NPM (et Python) contenant les donnÃ©es des Ã©lÃ©ments en JSON, avec des modules dâ€™accÃ¨s en TypeScript. Câ€™est pratique car on pourrait lâ€™installer et importer directement les donnÃ©es (ex: import { PERIODIC_TABLE } from "@mat3ra/periodic-table"). Ce dataset inclut aussi des donnÃ©es avancÃ©es (rayons atomiques, Ã©nergie de liaison de paires dâ€™Ã©lÃ©ments, couleurs standards des Ã©lÃ©ments, etc.)â€‹
github.com
â€‹
github.com
. Lâ€™intÃ©rÃªt ici est la facilitÃ© dâ€™intÃ©gration et la prÃ©sence de types TS prÃªts Ã  lâ€™emploi. Cependant, cela ajoute une dÃ©pendance supplÃ©mentaire au projet, et on doit faire confiance Ã  la maintenance du package.
Wikidata/Wikipedia API â€“ En alternative, on pourrait interroger Wikidata pour rÃ©cupÃ©rer certaines infos structurÃ©es (beaucoup dâ€™Ã©lÃ©ments ont leurs propriÃ©tÃ©s dans la base Wikidata) ou lâ€™API REST de Wikipedia pour obtenir le rÃ©sumÃ© intro dâ€™un article. Par exemple, lâ€™API de Wikipedia pourrait fournir directement la premiÃ¨re phrase du paragraphe dâ€™un Ã©lÃ©ment. Toutefois, sâ€™appuyer en direct sur Wikipedia Ã  chaque requÃªte pourrait Ãªtre lent et sujet aux modifications de contenu non maÃ®trisÃ©es. Mieux vaut utiliser le snapshot JSON mentionnÃ© plus haut qui fige un rÃ©sumÃ© validÃ©.
Sources officielles (IUPAC, NIST) â€“ Pour garantir lâ€™exactitude de certaines donnÃ©es (masse atomique standard, configurations Ã©lectroniques, etc.), on peut croiser nos informations avec des sources officielles. Lâ€™IUPAC publie pÃ©riodiquement les masses atomiques standard actualisÃ©es. De mÃªme, NIST fournit des donnÃ©es de rÃ©fÃ©rence sur les Ã©lÃ©ments. Ces sources sont trÃ¨s fiables, mais souvent fournies sous forme de tableaux PDF ou pages web, pas directement en JSON. On pourra donc vÃ©rifier que notre dataset est conforme aux derniÃ¨res donnÃ©es officielles, surtout pour des dÃ©tails comme les arrondis de masses atomiques ou les dÃ©nominations (par ex. le nom des Ã©lÃ©ments 113,115,117,118 qui ont Ã©tÃ© officialisÃ©s relativement rÃ©cemment).
Choix recommandÃ© : Pour dÃ©marrer, utiliser le JSON open-source (Bowserinator) apparaÃ®t comme la solution la plus simple et complÃ¨te. On peut lâ€™importer et le parcourir en TypeScript, et il contient dÃ©jÃ  la plupart des infos dÃ©sirÃ©es (y compris une anecdote courte via le rÃ©sumÃ© WikipÃ©dia). On devra Ã©ventuellement complÃ©ter par une anecdote plus Â« fun Â» si le rÃ©sumÃ© WikipÃ©dia est trop sÃ©rieux â€“ ce supplÃ©ment pourrait provenir dâ€™une autre source (livre dâ€™anecdotes scientifiques, articles de blog, etc.) quâ€™on intÃ©grerait manuellement. En tout cas, on sâ€™assurera de la fiabilitÃ© en privilÃ©giant les donnÃ©es avec source vÃ©rifiable (liens Wikipedia, rÃ©fÃ©rence RSC ou IUPAC) et en testant quelques Ã©chantillons de donnÃ©es pour sâ€™assurer quâ€™elles sont cohÃ©rentes et exactes.
4. Cahier des charges du projet
Voici un cahier des charges structurÃ© pour le site web interactif du tableau pÃ©riodique, compilant les objectifs et exigences du projet :
Public cible : Grand public, du collÃ©gien curieux de sciences Ã  lâ€™adulte amateur de culture scientifique. Le site doit Ãªtre comprÃ©hensible par des non-spÃ©cialistes, tout en Ã©tant suffisamment intÃ©ressant pour des connaisseurs. On vise aussi bien une utilisation Ã©ducative (Ã©tudiants, enseignants) quâ€™une consultation loisir par toute personne intriguÃ©e par un Ã©lÃ©ment.
Objectif gÃ©nÃ©ral : Proposer une visualisation interactive du tableau pÃ©riodique qui soit Ã  la fois Ã©ducative et ludique. Lâ€™utilisateur doit pouvoir explorer les Ã©lÃ©ments de maniÃ¨re intuitive, apprendre des faits scientifiques fiables, tout en passant un bon moment grÃ¢ce Ã  un ton engageant et des surprises (anecdotes amusantes, illustrations).
Contenu par Ã©lÃ©ment : Pour chaque Ã©lÃ©ment, fournir un mini-dossier composÃ© de :
Une courte description (quelques phrases) prÃ©sentant lâ€™Ã©lÃ©ment (par ex. sa dÃ©couverte, ses propriÃ©tÃ©s marquantes ou sa place dans la vie quotidienne).
2-3 usages typiques de lâ€™Ã©lÃ©ment (usages industriels, domestiques, biologiques, etc.), prÃ©sentÃ©s sous forme de puces ou dâ€™icÃ´nes.
Une anecdote scientifique amusante liÃ©e Ã  lâ€™Ã©lÃ©ment â€“ cela peut Ãªtre une curiositÃ© historique, une propriÃ©tÃ© Ã©tonnante, ou un fait moins connu mais divertissant. Le ton ici peut Ãªtre lÃ©ger, voire humoristique, tout en restant exact.
Des dÃ©tails supplÃ©mentaires dÃ©pliables : une section â€œen savoir plusâ€ que lâ€™utilisateur peut afficher pour voir des informations plus techniques (par exemple : propriÃ©tÃ©s physiques prÃ©cises, isotopes notables, prÃ©cautions de sÃ©curitÃ©, etc.). Cette section contiendra des donnÃ©es plus pointues pour les utilisateurs qui le souhaitent, sans encombrer la vue initiale.
FonctionnalitÃ©s clÃ©s :
Exploration par clic : Lâ€™utilisateur doit pouvoir cliquer (ou toucher) nâ€™importe quelle case du tableau pÃ©riodique pour voir apparaÃ®tre les informations de lâ€™Ã©lÃ©ment correspondant. Cela peut se faire via une navigation type â€œpage dÃ©tailâ€ ou une fenÃªtre modale superposÃ©e.
Recherche rapide : Une barre de recherche accessible permet de trouver un Ã©lÃ©ment par son nom (ex: â€œCarboneâ€), son symbole (â€œCâ€) ou son numÃ©ro atomique (â€œ6â€). La recherche se met Ã  jour en temps rÃ©el et propose des suggestions auto-complÃ©tÃ©es pour corriger dâ€™Ã©ventuelles fautes de frappe.
Filtres dynamiques : Un panneau de filtres permettra de restreindre lâ€™affichage Ã  certains sous-ensembles. Les filtres envisagÃ©s : par catÃ©gorie chimique (ex: mÃ©taux, non-mÃ©taux, mÃ©talloÃ¯desâ€¦), par famille (groupe du tableau, ex: halogÃ¨nes), par Ã©tat Ã  tempÃ©rature ambiante (solide/liquide/gaz), par propriÃ©tÃ© particuliÃ¨re (radioactifs, synthÃ©tiques, abondants/rÃ©siduelsâ€¦). En activant un filtre, les Ã©lÃ©ments correspondants seront mis en avant (ou les autres masquÃ©s) de maniÃ¨re visible.
Design responsive fluide : Le tableau doit rester navigable sur mobile. Sur Ã©cran tactile, lâ€™utilisateur pourra pincer pour zoomer sur le tableau, ou faire dÃ©filer pour voir les colonnes dÃ©bordantes. Alternativement, un mode dâ€™affichage listant les Ã©lÃ©ments par numÃ©ro pourrait Ãªtre proposÃ© sur mobile en complÃ©ment. Lâ€™objectif est quâ€™aucune information ne soit cachÃ©e ou illisible sur petit Ã©cran.
Internationalisation (i18n) : Le site intÃ¨gre dÃ¨s le dÃ©part le support de deux langues, franÃ§ais et anglais. Un commutateur (ex: drapeau ou code â€œFR/ENâ€) permettra de passer de lâ€™une Ã  lâ€™autre. Tous les textes de lâ€™UI, ainsi que les contenus des Ã©lÃ©ments, doivent donc Ãªtre prÃ©vus dans les deux langues. (Dans un premier temps, on peut remplir la version franÃ§aise et nâ€™utiliser lâ€™anglais quâ€™en interface, mais la structure doit permettre dâ€™ajouter la traduction anglaise du contenu facilement.)
Animations fluides : Lâ€™interface comportera des animations pour rendre lâ€™expÃ©rience plus vivante. Par exemple, au survol dâ€™un Ã©lÃ©ment, on peut le surligner ou afficher une info-bulle prÃ©liminaire. Lorsquâ€™on clique pour ouvrir la fiche dâ€™un Ã©lÃ©ment, lâ€™apparition de la fiche sera animÃ©e (transition en fondu, glissement, ou carte qui se retourne faÃ§on flip). Ces animations doivent renforcer la comprÃ©hension (indiquer clairement ce qui se passe) et le plaisir dâ€™utilisation, sans ralentir ni gÃªner la navigation.
Technologies imposÃ©es :
Framework : Svelte (version vanilla, sans SvelteKit). On utilisera Svelte pour construire une application web rÃ©active monopage (SPA).
Langage : TypeScript pour la robustesse (dÃ©tection dâ€™erreurs de types, autocomplÃ©tion, etc.).
UI Library : Tailwind CSS pour accÃ©lÃ©rer le dÃ©veloppement du design (utilisation dâ€™utilitaires de style directement dans les composants). En complÃ©ment, possible utilisation de shadcn/ui pour des composants prÃ©-stylÃ©s (mÃªme si conÃ§u Ã  lâ€™origine pour React, on peut sâ€™inspirer de leurs principes dâ€™UI et reproduire des composants Ã©quivalents en Svelte, par exemple pour les boutons, onglets, tooltips, etc., en utilisant Tailwind).
Animations : GSAP (GreenSock) ou Framer Motion. GSAP, trÃ¨s puissant en JS pur, pourra Ãªtre appelÃ© dans les hooks Svelte (onMount par ex.) pour orchestrer des animations complexes. Framer Motion a une version pour React, donc probablement GSAP conviendra mieux ici, sauf si on trouve une librairie Ã©quivalente pour Svelte. Dans tous les cas, lâ€™animation sera codÃ©e en JS/TS au sein de composants Svelte.
Structure : Ã‰tant sans SvelteKit, le site reposera sur un seul fichier HTML faisant appel au bundle JS/CSS gÃ©nÃ©rÃ©. On pourra utiliser un router JS pour gÃ©rer les vues (par ex. Routify ou un simple mÃ©canisme maison basÃ© sur lâ€™URL hash ou History API).
Outils de build : Vite ou Rollup (gÃ©nÃ©ralement le template Svelte utilise Rollup ou Vite par dÃ©faut) pour transpiler le code TS et assembler le bundle, avec configuration pour Tailwind (postCSS) et minification en production.
Contraintes de livraison : La version initiale sera livrÃ©e en franÃ§ais entiÃ¨rement fonctionnelle, avec lâ€™infrastructure prÃªte pour lâ€™anglais (fichiers de langue, etc.). Le code source sera propre et bien documentÃ© pour faciliter les Ã©volutions. On privilÃ©gie une architecture front-end statique (pas de backend requis, hormis Ã©ventuellement servir le fichier JSON des Ã©lÃ©ments). Le site devra Ãªtre hÃ©bergeable facilement (par ex. sur GitHub Pages, Vercel, Netlifyâ€¦) et charger rapidement mÃªme avec la richesse de contenu (on fera attention au poids des assets comme les images ou les bibliothÃ¨ques JS ajoutÃ©es).
Ce cahier des charges servira de rÃ©fÃ©rence tout au long du dÃ©veloppement pour garder le cap sur les objectifs et sâ€™assurer que toutes les fonctionnalitÃ©s attendues sont bien mises en Å“uvre.
5. Guidelines UI/UX (palette, espacement, animations, interactions)
Pour offrir une expÃ©rience utilisateur Ã  la fois agrÃ©able et cohÃ©rente, nous allons respecter certaines lignes directrices UI/UX tout au long du design :
Charte graphique & palette de couleurs : On adoptera une palette moderne, Ã©voquant la science tout en restant joyeuse. Par exemple, on peut partir sur un fond clair neutre et utiliser des couleurs vives pour les diffÃ©rents types dâ€™Ã©lÃ©ments (comme câ€™est lâ€™usage dans les tableaux pÃ©riodiquesÂ : mÃ©taux alcalins en rose/rouge, mÃ©taux de transition en vert ou bleu, gaz nobles en pourpre, etc.). Ces couleurs serviront de repÃ¨res visuels. Il faudra aussi une palette secondaire pour lâ€™UI (boutons, en-tÃªtesâ€¦). On choisira 2 ou 3 couleurs principales harmonieuses (par ex. un bleu pÃ©trole pour le header, rappelant la confiance scientifique, combinÃ© Ã  une couleur dâ€™accent plus vive â€“ orange ou vert â€“ pour les surbrillances ludiques). Le contraste sera suffisant pour assurer la lisibilitÃ© (texte blanc sur fond colorÃ© pour les labels dâ€™Ã©lÃ©ments par ex.). On peut Ã©galement prÃ©voir un mode sombre en option, vu la popularitÃ© de cette fonctionnalitÃ© â€“ Tailwind facilite la gestion de thÃ¨mes (classes dark:).
Typographie et lisibilitÃ© : Opter pour une police sans-serif moderne, facile Ã  lire Ã  lâ€™Ã©cran (par ex. Inter, Roboto ou Source Sans Pro). Les titres dâ€™Ã©lÃ©ments pourraient Ãªtre dans une font un peu plus fun ou stylÃ©e, mais il faut rester sobre pour le corps du texte. Les tailles de police seront modulaires : suffisamment grandes pour Ãªtre lisibles mÃªme sur mobile (au moins 14px pour le texte de base, 10-12px minimum pour les numÃ©ros atomiques sur la grille qui seront de toute faÃ§on trÃ¨s courts). Lâ€™usage de Tailwind permettra dâ€™appliquer des espacements cohÃ©rents (marges/paddings suivant une Ã©chelle 4,8,16px etc.) assurant une mise en page aÃ©rÃ©e. Les paragraphes de description seront concis (2-3 phrases max) et sÃ©parÃ©s par des espacements pour ne pas former un bloc compact. On veillera aux alignements (par ex. aligner les cases dâ€™Ã©lÃ©ments bien en grille, aligner les titres et textes dans la fiche Ã©lÃ©ment). Lâ€™UI doit paraÃ®tre propre et organisÃ©e.
Disposition et navigation : Sur desktop, on peut afficher le tableau pÃ©riodique en pleine largeur (responsive, centrÃ©). Un menu ou une barre supÃ©rieure contiendra la recherche et dâ€™Ã©ventuels boutons (filtre, switch de langue, toggle sombre). La fiche dâ€™un Ã©lÃ©ment sâ€™ouvrira soit dans un panneau latÃ©ral escamotable, soit dans une modal centrÃ©e. Le choix dÃ©pendra des tests UX : un panneau latÃ©ral permet de garder le tableau visible en arriÃ¨re-plan, ce qui aide Ã  se situer (contexte), tandis quâ€™une modal centrÃ©e focalise lâ€™attention sur lâ€™Ã©lÃ©ment (et le tableau pourrait Ãªtre en fond assombri). On pourrait implÃ©menter lâ€™un puis Ã©valuer. Sur mobile, si lâ€™Ã©cran est petit, il serait peut-Ãªtre prÃ©fÃ©rable quâ€™un clic ouvre la fiche en plein Ã©cran (une nouvelle vue) pour utiliser tout lâ€™espace disponible verticalement. Dans ce cas, un bouton de retour (back) ou une croix de fermeture sera bien visible pour revenir au tableau.
Interactions intuitives : Chaque Ã©lÃ©ment de la grille sera rendu comme un bouton (accessibilitÃ© ARIA) : il change de style au survol (highlight) et au focus (pour navigation clavier). Cliquer/toucher dÃ©clenche lâ€™ouverture de la fiche. Le survol peut aussi afficher une mini-info-bulle avec le nom complet de lâ€™Ã©lÃ©ment si lâ€™affichage est rÃ©duit (utile sur mobile ou si on nâ€™affiche que le symbole). La recherche doit Ãªtre accessible via un raccourci (par ex. appui sur la touche "/" pour focus la barre de recherche, comme sur beaucoup de sites, ce qui est pratique pour les power-users). Les filtres auront des libellÃ©s clairs et une indication visuelle lorsquâ€™ils sont actifs (par ex. bouton en surbrillance). En activant un filtre, on pourrait animer les cases non correspondantes en les grisant ou en les masquant avec une transition douce, pour bien signaler le rÃ©sultat du filtre.
Animations et micro-interactions : Lâ€™usage de GSAP/Framer Motion sera ciblÃ© sur des animations qualitatives :
Lors du chargement initial, on peut animer lâ€™apparition du tableau (par ex. les cases qui se mettent en place avec un lÃ©ger dÃ©calage, ou un effet de fade-in global).
Lorsquâ€™un Ã©lÃ©ment est cliquÃ©, sa carte de dÃ©tail peut apparaÃ®tre avec un effet sympa â€“ par exemple, une transition qui zoome depuis la case cliquÃ©e vers le panneau de dÃ©tail (donnant lâ€™impression que la case sâ€™agrandit pour devenir la fiche). Alternativement, un effet de flip card: la case se retourne pour montrer son verso (contenant les infos). Ce type dâ€™animation rend lâ€™expÃ©rience plus tangible.
Les transitions page/retour sur mobile (si on change de route) seront optimisÃ©es pour sembler natives (glissement latÃ©ral, etc., cohÃ©rent avec les guidelines iOS/Material).
De petites animations de survol : par ex., un hover sur les boutons de filtre fait apparaÃ®tre un tooltip explicatif, un shake lÃ©ger dâ€™un icÃ´ne de filtre pour attirer lâ€™attention si lâ€™utilisateur semble chercher quelque chose, etc., mais sans excÃ¨s pour ne pas distraire inutilement.
Performance : toutes les animations devront Ãªtre fluides (60 fps idÃ©alement) et non bloquantes. On utilisera les capacitÃ©s de CSS (transitions GPU) ou GSAP timeline optimisÃ©es. De plus, prÃ©voir une dÃ©gradation Ã©lÃ©gante : si lâ€™appareil de lâ€™utilisateur est ancien ou si lâ€™option â€œrÃ©duire les animationsâ€ est activÃ©e dans son OS, nos animations doivent soit se dÃ©sactiver, soit Ãªtre trÃ¨s allÃ©gÃ©es pour privilÃ©gier la lisibilitÃ©.
Illustrations et Ã©lÃ©ments visuels : Pour le cÃ´tÃ© fun, on intÃ¨grera des petites illustrations ou emojis/mÃªmes Ã  dose mesurÃ©e. Par exemple, Ã  cÃ´tÃ© de lâ€™anecdote amusante, un petit emoji ğŸ˜œ ou une icÃ´ne humoristique peut signaler le ton lÃ©ger. On peut imaginer que chaque Ã©lÃ©ment ait un pictogramme ou une mini-image associÃ©e symbolisant un usage (Ã  la maniÃ¨re du tableau illustrÃ© en images vu plus haut). On pourrait rÃ©utiliser des images libres de droit ou des pictos stylisÃ©s (pack dâ€™icÃ´nes type FontAwesome ou HeroIcons, ou des illustrations SVG custom). Ces visuels doivent rester secondaires par rapport au texte, pour ne pas surcharger lâ€™UI. Un Ã©quilibre est Ã  trouver entre enrichir visuellement et garder une interface claire.
Consistance et feedback utilisateur : Lâ€™expÃ©rience sera uniformisÃ©e : mÃªmes codes couleur pour les mÃªmes catÃ©gories partout, style cohÃ©rent entre les boutons, champs, etc. (dâ€™oÃ¹ lâ€™intÃ©rÃªt de shadcn/ui ou au moins de suivre un design system). Chaque action utilisateur doit avoir un retour visuel : un clic sur un Ã©lÃ©ment donne lâ€™impression de bouton enfoncÃ©, lâ€™ouverture dâ€™une fiche fait apparaÃ®tre un nouveau contenu de maniÃ¨re Ã©vidente. Si un filtre nâ€™a aucun rÃ©sultat (par ex. filtrer â€œgazâ€ puis â€œsolideâ€ en mÃªme temps, contradiction), le site affichera un petit message (â€œAucun Ã©lÃ©mentâ€) ou une indication pour Ã©viter la confusion.
En appliquant ces guidelines, on obtiendra une interface intuitive, esthÃ©tique et fluide. Lâ€™utilisateur pourra naviguer avec plaisir, en comprenant rapidement comment interagir (grÃ¢ce aux indices visuels) et en profitant dâ€™une prÃ©sentation claire de lâ€™information. Lâ€™aspect ludique (animations, anecdotes, visuels) gardera son intÃ©rÃªt sans compromettre la rigueur ni la performance.
6. Architecture de routing et logique de navigation
MÃªme sans utiliser SvelteKit, nous devons organiser lâ€™application en plusieurs vues/pages logiques pour structurer la navigation. Ã‰tant une SPA (single-page app) Svelte, le routing sera gÃ©rÃ© cÃ´tÃ© client, mais il faut le penser comme un enchaÃ®nement de â€œpagesâ€ pour lâ€™utilisateur. Voici une proposition dâ€™architecture de navigationÂ :
Page dâ€™accueil â€“ Tableau pÃ©riodique : Lâ€™URL de base (par ex. / ou /index.html) affichera le tableau pÃ©riodique complet. Câ€™est la vue principale contenant :
La grille interactive des Ã©lÃ©ments (composant <PeriodicTable>).
La barre de recherche et les contrÃ´les de filtre (composant <Toolbar> en haut, Ã©ventuellement).
Peut-Ãªtre une introduction courte ou un encart â€œsaviez-vous que?â€ qui accueille lâ€™utilisateur la premiÃ¨re fois, mais le focus reste sur la table.
En mode desktop, tout est sur une page. En mode mobile, cette page scrollable permet dÃ©jÃ  de naviguer dans la table.
Page dÃ©tail dâ€™un Ã©lÃ©ment : Accessible via une route de type /element/Â«Â symboleÂ Â» ou /element/Â«Â numÃ©roÂ Â». Par exemple /element/Fe pour le fer ou /element/26 (selon quâ€™on choisit symbole ou numÃ©ro dans lâ€™URL). Cette page dÃ©tail affichera le composant <ElementDetails> qui prÃ©sente les informations complÃ¨tes sur lâ€™Ã©lÃ©ment sÃ©lectionnÃ© (description, usages, anecdote, etc. comme dÃ©fini dans le cahier des charges).
Sur desktop, on peut rÃ©aliser ceci avec un routeur interne sans rÃ©ellement changer de page : par exemple, si lâ€™URL change, on affiche la fiche en overlay tout en restant sur la mÃªme page. Mais conceptuellement, câ€™est une page distincte.
Sur mobile ou si lâ€™utilisateur accÃ¨de directement Ã  cette URL, lâ€™app SPA doit Ãªtre capable de rendre le dÃ©tail seul (il faut donc que lâ€™Ã©tat de lâ€™application gÃ¨re ce cas, par ex. en lisant le paramÃ¨tre de route et en affichant directement lâ€™Ã©lÃ©ment).
La page dÃ©tail comportera un bouton/back pour revenir Ã  la vue tableau (peut Ãªtre implÃ©mentÃ© via window.history.back() ou un lien vers /). On peut aussi offrir des boutons â€œPrÃ©cÃ©dent/Suivantâ€ Ã©lÃ©ment pour feuilleter les Ã©lÃ©ments voisins (utile dans un contexte dâ€™apprentissage sÃ©quentiel, mais pas strictement nÃ©cessaire).
Lâ€™URL distincte est importante pour le partage : lâ€™utilisateur pourra envoyer un lien direct vers la page dâ€™un Ã©lÃ©ment particulier Ã  quelquâ€™un dâ€™autre.
Pages annexes : Bien que non exigÃ©es explicitement, on peut envisager de petites pages complÃ©mentaires pour complÃ©ter le site :
Une page â€œÃ€ proposâ€ (/about par ex.) prÃ©sentant le projet, les auteurs, les sources des donnÃ©es (crÃ©dits Wikipedia, etc.) et les remerciements. Ceci est une bonne pratique et peut Ãªtre utile pour respecter les licences (par ex. si on rÃ©utilise des contenus CC-BY-SA de Wiki).
Une page â€œGuideâ€ ou â€œAideâ€ qui explique comment utiliser les filtres, la recherche, et Ã©ventuellement un rappel de ce que signifient les codes couleur du tableau, etc. Ce pourrait Ãªtre un simple modal dâ€™aide plutÃ´t quâ€™une page Ã  part entiÃ¨re.
Si on pousse la dimension pÃ©dagogique, une page â€œQuizâ€ ou â€œJeuâ€ pourrait Ãªtre imaginÃ©e plus tard (ex: trouver lâ€™Ã©lÃ©ment Ã  partir dâ€™une devinette), mais ce nâ€™est pas dans le pÃ©rimÃ¨tre initial.
En termes de logique de navigation, voici comment cela se traduitÂ :
Par dÃ©faut, lâ€™application charge la vue tableau. Si lâ€™URL contient dÃ©jÃ  un hash/chemin vers un Ã©lÃ©ment, le routeur doit dÃ©tecter ce paramÃ¨tre et afficher directement lâ€™Ã©lÃ©ment concernÃ©.
Cliquer sur un Ã©lÃ©ment dÃ©clenche une action de navigation interne : par exemple, on pourrait utiliser location.hash = "#/element/Fe" pour mettre Ã  jour lâ€™URL (ou utiliser lâ€™History API pour push un Ã©tat /element/Fe sans recharger la page). Svelte, combinÃ© avec un mini-routeur, va alors rendre la vue dÃ©tail.
Lâ€™application doit gÃ©rer la navigation avant/arriÃ¨re du navigateur : si lâ€™utilisateur appuie sur â€œretourâ€ aprÃ¨s avoir vu un Ã©lÃ©ment, il revient Ã  la table (Ã©tat prÃ©cÃ©dent). Inversement, sâ€™il clique un Ã©lÃ©ment, lâ€™historique avance.
Le passage de la page table Ã  la page dÃ©tail peut Ãªtre animÃ© (comme mentionnÃ© en UX). Techniquement, on peut soit garder le composant tableau montÃ© et superposer le dÃ©tail, soit dÃ©truire/monter selon la route. Ã‰tant donnÃ© que le tableau nâ€™est pas lourd (118 Ã©lÃ©ments), on peut le laisser en arriÃ¨re-plan pour un retour instantanÃ©.
Pour la recherche : si lâ€™utilisateur tape dans la barre de recherche un nom dâ€™Ã©lÃ©ment et valide, on peut soit filtrer la vue tableau (par ex. zoomer ou isoler lâ€™Ã©lÃ©ment correspondant dans la grille), soit le rediriger directement vers la page dÃ©tail de cet Ã©lÃ©ment sâ€™il y a correspondance exacte. Une UX pratique serait dâ€™avoir les deux : suggestions en dropdown sous le champ de recherche, cliquer une suggestion amÃ¨ne Ã  la page de lâ€™Ã©lÃ©ment.
Pour les filtres : il sâ€™agit plus dâ€™une interaction sur la page tableau elle-mÃªme que de vraies pages. Par exemple, sÃ©lectionner un filtre â€œmÃ©tauxâ€ ne change pas de route, Ã§a agit sur le composant tableau (on ne va pas faire une route par filtre combinatoire). On pourrait cependant reflÃ©ter lâ€™Ã©tat de filtre dans lâ€™URL via une query string ou un hash (ex: /#?filter=metal), mais ce nâ€™est pas indispensable. Lâ€™important est que lâ€™utilisateur puisse combiner plusieurs critÃ¨res et que la vue se mette Ã  jour en consÃ©quence.
ImplÃ©mentation technique du routing : Sans SvelteKit, on peut utiliser un routeur lÃ©ger. Par exemple, svelte-spa-router (une lib communautaire) ou simplement Ã©crire une fonction qui lit window.location.pathname ou hash et montre le bon composant. Une architecture possible est dâ€™avoir dans App.svelte un bloc {#if} qui choisit le composant Ã  montrer selon une store currentRoute. PseudocodeÂ :
svelte
Copier
Modifier
<script>
  import PeriodicTable from './PeriodicTable.svelte';
  import ElementDetails from './ElementDetails.svelte';
  $: route = $currentRoute; // store that updates on popstate or hashchange
</script>

{#if route.page === 'home'}
  <PeriodicTable />
{:elseif route.page === 'element'}
  <ElementDetails elementId={route.param} />
{:elseif route.page === 'about'}
  <AboutPage/>
{/if}
On mettra en place les listeners sur window.onpopstate pour maj currentRoute, et utiliser history.pushState lors des navigations internes. Ce schÃ©ma assurera une navigation fluide sans rechargement. En rÃ©sumÃ©, lâ€™application aura deux vues principales (tableau et dÃ©tail), Ã©ventuellement enrichies de 1-2 pages info. La navigation devra Ãªtre intuitive (simuler un vrai site multi-pages tout en restant une SPA) et gÃ©rer lâ€™URL pour lâ€™accÃ¨s direct et le partage. Cette architecture garantit que le site se comporte comme une application moderne : un utilisateur peut bookmarker la page dâ€™un Ã©lÃ©ment, y accÃ©der directement, et revenir Ã  la table sans confusion.
7. Contraintes techniques (responsive, i18n, performances, etc.)
Lors du dÃ©veloppement, plusieurs contraintes techniques transversales devront Ãªtre respectÃ©es pour assurer la qualitÃ© du produit final :
Responsive design : Câ€™est un point crucial compte tenu de la nature du tableau pÃ©riodique. On devra tester lâ€™affichage sur diverses rÃ©solutions :
Mobile (~360px de large) : Le tableau de 18 colonnes + 2 rangÃ©es dÃ©tachÃ©es (lanthanides/actinides) ne tiendra pas en une seule vue sans scroll. Solutions : autoriser un scroll horizontal de la grille dans un conteneur, ou rÃ©duire la taille des cellules et afficher une grille compressÃ©e. Une option intÃ©ressante est de passer en mode â€œcarteâ€ sur mobile : afficher chaque pÃ©riode lâ€™une en dessous de lâ€™autre, ou un carrousel par bloc. NÃ©anmoins, cela casse la reprÃ©sentation classique. Il est sans doute prÃ©fÃ©rable de garder la reprÃ©sentation standard et de la rendre scrollable (lâ€™utilisateur balaie pour voir les groupes Ã  droite). On utilisera Tailwind CSS pour crÃ©er une grille flexible (par ex. grid-cols-18 sur desktop, et peut-Ãªtre grid-cols-7 sur mobile avec des sauts de ligne pour groupes, etc.). On devra ajuster la taille du texte et des marges pour que chaque case reste cliquable au doigt (taille min ~40px).
Tablettes (~768px - 1024px) : Ici, on peut peut-Ãªtre afficher la table entiÃ¨re si chaque case est plus petite, ou prÃ©voir un lÃ©ger scroll. On vÃ©rifiera que les labels (numÃ©ro, symbole, nom Ã©ventuellement) restent visibles. Sur tablette, la fiche Ã©lÃ©ment pourrait sâ€™afficher en overlay Ã  cÃ´tÃ© du tableau si lâ€™orientation est paysage.
Desktop grand Ã©cran : Veiller Ã  ce que le tableau ne â€œnageâ€ pas dans un Ã©cran ultra large non plus. On peut centrer le contenu et fixer une largeur max pour le tableau (par ex. limiter Ã  ~1200px de large pour le tableau lui-mÃªme, sinon les espaces entre Ã©lÃ©ments deviennent trop grands).
Tests multi-navigateurs : On sâ€™assurera du rendu sur Chrome, Firefox, Safari, Edge, ainsi que sur WebView mobile (Chrome Android, Safari iOS). Svelte gÃ©nÃ¨re du code largement compatible ES5+, donc Ã§a devrait fonctionner partout sauf IE (public peu pertinent en 2025). Tailwind et GSAP sont aussi compatibles cross-browser. Attention toutefois aux API CSS utilisÃ©es (grid, flex, etc. sont bien supportÃ©s maintenant).
Internationalisation (i18n) : Techniquement, dÃ¨s le dÃ©part, on structurera le projet pour supporter plusieurs langues :
On aura par exemple un dossier src/i18n/ avec des fichiers JSON ou JS pour les textes : fr.json et en.json. Dedans, on stocke les traductions de toutes les chaÃ®nes utilisÃ©es dans lâ€™UI (libellÃ©s de boutons, titres de sections, texte de lâ€™anecdote, etc.) par clÃ©s.
Pour le contenu des Ã©lÃ©ments, deux approches : soit on intÃ¨gre dÃ¨s le JSON des Ã©lÃ©ments les diffÃ©rentes langues (ex: name_fr, description_fr, etc.), soit on maintient deux fichiers de donnÃ©es parallÃ¨les (moins DRY). Mieux vaut enrichir la structure JSON initiale pour inclure les noms franÃ§ais des Ã©lÃ©ments par exemple. On peut Ã©galement prÃ©voir que lâ€™anecdote soit diffÃ©rente en fonction de la culture (une blague peut nÃ©cessiter adaptation).
Utilisation : dans Svelte, on pourra crÃ©er un store currentLang et un helper $t(key) qui va chercher la chaÃ®ne correspondante. Il existe des librairies comme svelte-i18n qui peuvent aider Ã  charger les dictionnaires et fournir un $_ (translator function). On doit veiller Ã  ce que le basculement de langue rafraÃ®chisse bien tous les textes affichÃ©s (Svelte re-rendra si le store de langue change).
Au niveau de lâ€™URL, on pourrait coder la langue, ex. /fr/element/Fe vs /en/element/Fe. Mais Ã§a complique le routage sans SvelteKit. On peut plutÃ´t gÃ©rer la langue en interne (ex: stocker le choix en localStorage ou dans lâ€™URL query ?lang=en). Pour la premiÃ¨re version, un simple toggle dans lâ€™UI suffira.
Contenu non traduit : tant que la version anglaise du contenu dÃ©taillÃ© nâ€™est pas prÃªte, il faudra dÃ©cider : afficher le contenu FR mÃªme si lâ€™UI est en anglais (avec un petit message â€œcontent available in French only pour lâ€™instantâ€), ou bien masquer les textes non traduits. Il serait idÃ©al dâ€™au moins fournir les noms dâ€™Ã©lÃ©ments en anglais si UI en anglais, pour consistance.
Enfin, il faudra tester le formatage (par ex. les nombres dÃ©cimaux virgule vs point, unitÃ©s) selon la locale, bien que la plupart des donnÃ©es chimiques seront des constantes identiques entre langues (sauf le nom de lâ€™unitÃ©, ex â€œg/cmÂ³â€ reste pareil).
Performance et optimisation :
Lâ€™application doit Ãªtre rapide Ã  charger et rÃ©active. Svelte aide beaucoup car câ€™est un framework sans virtual DOM, qui gÃ©nÃ¨re du JS optimisÃ© et met Ã  jour le DOM de faÃ§on trÃ¨s ciblÃ©eâ€‹
svelte.dev
. De plus, Svelte nâ€™embarque quâ€™un runtime minimal, ce qui rÃ©duit la taille du bundle. On exploitera ces atouts.
On fera attention au poids des assets : le JSON des Ã©lÃ©ments peut Ãªtre volumineux (~100 KB peut-Ãªtre). On pourrait le charger de maniÃ¨re asynchrone aprÃ¨s lâ€™affichage initial (ex: afficher la table vide puis remplir, mais ce nâ€™est pas idÃ©al visuellement). Comme il sâ€™agit dâ€™une SPA, on peut aussi inclure le JSON dans le bundle directement (via un import, webpack/vite va lâ€™intÃ©grer). Il faudra mesurer ce qui est mieux. Si on inclut GSAP, câ€™est ~50 KB minifiÃ©s; Tailwind CSS purge les classes non utilisÃ©es donc le CSS final sera optimisÃ©.
Les images/illustrations doivent Ãªtre lÃ©gÃ¨res : si on dÃ©cide dâ€™avoir une icÃ´ne par Ã©lÃ©ment, on utilisera soit une police dâ€™icÃ´nes SVG (trÃ¨s lÃ©ger) soit des petites images compressÃ©es. Tout ce qui est mÃ¨me/emoji peut souvent Ãªtre fait en Unicode ou CSS (ex: âš›ï¸ pour lâ€™atome).
RafraÃ®chissements : Svelte rendra le composant global en une fois. Il y aura potentiellement 118 sous-composants (chaque case). Il faut sâ€™assurer que mettre Ã  jour un Ã©tat (ex: activer un filtre) ne va pas refaire un DOM diff Ã©norme. IdÃ©alement, chaque case peut avoir une classe liÃ©e aux filtres, et Svelte peut mettre Ã  jour seulement les cases concernÃ©es. 118 nâ€™est pas un grand nombre, donc mÃªme un re-render total reste envisageable (peu de coÃ»t).
Animations : Utiliser GSAP nÃ©cessite dâ€™animer en JS. Il faudra veiller Ã  ne pas bloquer le thread principal. On utilisera requestAnimationFrame via GSAP qui est bien optimisÃ©. On Ã©vitera les animations de trop longue durÃ©e simultanÃ©es. Aussi, stopper/nettoyer les animations quand on quitte une page (ex: si on navigue alors quâ€™une animation est en cours).
Lazy loading : Si certaines parties du site sont lourdes et pas immÃ©diatement utiles, on pourrait les charger Ã  la demande. Par exemple, si on avait une section â€œvidÃ©o explicativeâ€ intÃ©grÃ©e (YouTube), on ne la chargerait quâ€™au clic. Ou si on intÃ©grait les modÃ¨les 3D de Bohr (le JSON Bowserinator mentionne des liens glTF pour chaque Ã©lÃ©ment), on ne chargerait ces modÃ¨les que si lâ€™utilisateur choisit de les voir. Bref, charger progressivement pour ne pas impacter la performance initiale.
Profiling : On fera des tests de performance (Lighthouse, etc.) pour sâ€™assurer que le site obtient de bons scores (notamment sur mobile). Lâ€™objectif est que le site se charge en quelques secondes mÃªme en 3G, et que toutes les interactions soient fluides.
AccessibilitÃ© : En plus dâ€™Ãªtre responsive, le site doit Ãªtre utilisable par le plus grand nombre, y compris avec des aides techniques :
On ajoutera des attributs ARIA pertinents : role="table" pour la grille, role="button" + aria-label sur chaque case (ex: <div role="button" aria-label="HydrogÃ¨ne, Ã©lÃ©ment 1">H</div>), ainsi une lecture dâ€™Ã©cran pourra Ã©noncer lâ€™Ã©lÃ©ment sous le focus.
NavigabilitÃ© clavier : sâ€™assurer quâ€™on peut tabuler Ã  travers les Ã©lÃ©ments du tableau (peut-Ãªtre faire un focus loop spÃ©cifique, ou utiliser les flÃ¨ches pour naviguer comme un vÃ©ritable tableau, ce serait top en UX avancÃ©e). Ã€ minima, tab doit aller sur la grille, puis permettre dâ€™entrer dans la grille.
Contrastes de couleurs : respecter les ratios AA ou AAA pour le texte sur fond colorÃ© (les personnes daltoniennes doivent pouvoir distinguer les catÃ©gories, donc peut-Ãªtre ajouter un motif ou un symbole en plus de la couleur pour indiquer un groupe).
PrÃ©voir une fallback si JS dÃ©sactivÃ© : probablement le site ne fonctionnera pas (Ã©tant une SPA), mais on peut quand mÃªme mettre un message invitant Ã  activer JS. On pourrait offrir une version statique minimale du tableau (par ex. un lien vers une image PNG du tableau pÃ©riodique) en dernier recours.
MaintenabilitÃ© et Ã©volutivitÃ© : Au-delÃ  des contraintes immÃ©diates, on code de maniÃ¨re Ã  pouvoir faire Ã©voluer le site. Par exemple, lâ€™architecture i18n doit permettre dâ€™ajouter une langue supplÃ©mentaire facilement. La structure des donnÃ©es doit accepter dâ€™ajouter un champ (imaginons quâ€™on veuille rajouter â€œdÃ©couverteâ€ ou â€œÃ©tat de la matiÃ¨re Ã  0Kâ€ plus tard). Respecter les principes SOLID/DRY (dÃ©taillÃ©s en partie 8) est aussi une contrainte technique pour garder un code propre. On documentera le code pour que dâ€™autres dÃ©veloppeurs ou nous-mÃªme dans 6 mois puissions sâ€™y replonger sans peine.
SÃ©curitÃ© et fiabilitÃ© : MÃªme si câ€™est une appli front sans donnÃ©es sensibles, on fera attention aux Ã©ventuels contenus externes. Par exemple, si on intÃ¨gre des extraits de Wikipedia, on veillera Ã  filtrer ce qui pourrait Ãªtre malveillant (script). Mais comme on passera par un JSON maÃ®trisÃ©, Ã§a devrait aller. On sâ€™assurera aussi de bien gÃ©rer les erreurs (si un Ã©lÃ©ment nâ€™a pas de donnÃ©es dispo, afficher â€œinfo non disponibleâ€ plutÃ´t quâ€™une page blanche). Testez les cas limites : ex. accÃ©der Ã  /element/XYZ avec XYZ inexistant doit renvoyer vers la page dâ€™accueil ou montrer un message dâ€™erreur clair.
En respectant ces contraintes techniques, on sâ€™assure que le site ne sera pas seulement attractif, mais aussi robuste et accessible dans la pratique, quelles que soient les conditions dâ€™utilisation (appareil, langue, contexte rÃ©seau). La rÃ©ussite du projet dÃ©pend autant de ces dÃ©tails techniques que des fonctionnalitÃ©s visibles.
8. RÃ¨gles de dÃ©veloppement du projet (SOLID, DRY, code modulaireâ€¦)
Pour garantir la qualitÃ© du code et la facilitÃ© de maintenance, le projet suivra un ensemble de rÃ¨gles et bonnes pratiques de dÃ©veloppement, adaptÃ©es Ã  Svelte et aux principes gÃ©nÃ©raux (SOLID, DRY, etc.) :
Organisation modulaire du code : On divisera le projet en composants Svelte et modules de fonction distincts, chacun ayant une responsabilitÃ© claire (Single Responsibility Principle du SOLID). Par exemple, un composant ElementCard.svelte ne fera que lâ€™affichage dâ€™une case Ã©lÃ©ment dans la grille, un composant ElementModal.svelte gÃ©rera lâ€™affichage des dÃ©tails dâ€™un Ã©lÃ©ment, un module dataService.ts sera responsable de charger/fournir les donnÃ©es des Ã©lÃ©ments. Cette sÃ©paration rend le code plus lisible et facilite les tests/unitaires Ã©ventuels.
DRY (Donâ€™t Repeat Yourself) : Ã‰viter la duplication de code ou de logique. Sâ€™il y a des styles redondants, on les factorise via Tailwind (en utilisant des classes utilitaires rÃ©utilisables ou des composants). Sâ€™il y a des valeurs constantes utilisÃ©es Ã  plusieurs endroits (par ex. liste des catÃ©gories dâ€™Ã©lÃ©ments, ou palette de couleurs), on les dÃ©finira une fois (dans un fichier de config). Par exemple, la logique de filtrage peut Ãªtre centralisÃ©e : au lieu de coder dans 5 endroits la condition â€œsi Ã©lÃ©ment.category == filtreâ€, on crÃ©e une fonction utilitaire filterElements(elements, criteria) quâ€™on rÃ©utilise. De mÃªme pour formater une unitÃ© ou trier par numÃ©ro. Le but est de minimiser les sources dâ€™erreur et de simplifier les modifications futures (changer une rÃ¨gle de filtre dans une fonction unique plutÃ´t que traquer 5 duplications).
Nommage clair et cohÃ©rence : Les variables, fonctions et composants auront des noms explicites, en anglais dans le code (convention de dev, par ex. currentElement, openModal(), etc.). On utilisera une convention de casse cohÃ©rente (camelCase pour variables/fonctions JS, PascalCase pour composants Svelte, SCREAMING_SNAKE_CASE pour constantes globales). Les fichiers seront organisÃ©s par fonctionnalitÃ© (par ex. un dossier components/ avec sous-dossiers Table/, ElementDetails/, etc., un dossier data/ pour les fichiers JSON ou TS de donnÃ©es). Cette structuration aide Ã  sâ€™y retrouver dans le projet.
Principe dâ€™Ouvert/FermÃ© (SOLID) : Le code est conÃ§u pour Ãªtre ouvert Ã  lâ€™extension mais fermÃ© Ã  la modification. En pratique, cela signifie quâ€™on prÃ©fÃ¨re ajouter de nouvelles instances ou donnÃ©es plutÃ´t que modifier le code existant pour changer un comportement. Par exemple, si on veut ajouter un troisiÃ¨me langage plus tard, on ne doit pas avoir Ã  rÃ©Ã©crire toute la logique dâ€™i18n â€“ il suffira dâ€™ajouter un fichier de langues. Cela implique dâ€™anticiper un peu : on paramÃ©trera les textes via des clÃ©s et non en dur, on utilisera des structures de donnÃ©es (objets, tableaux) quâ€™on peut allonger. De mÃªme, pour les filtres, on pourrait stocker la dÃ©finition des filtres dans un tableau dâ€™objets (nom, fonction de critÃ¨re) et boucler dessus pour gÃ©nÃ©rer les boutons. Ainsi, ajouter un nouveau filtre revient Ã  ajouter un objet dans ce tableau, pas Ã  coder un nouveau if ailleurs. Cette approche modulaire et extensible Ã©vite dâ€™introduire des bugs en modifiant le cÅ“ur du code.
Utilisation judicieuse de TypeScript : TypeScript nous aide Ã  respecter lâ€™interface des donnÃ©es et Ã  attraper des erreurs tÃ´t. On dÃ©finira des interfaces/types clairs, par ex. interface ElementData { number: number; symbol: string; name_fr: string; name_en: string; category: string; â€¦ }. Ces types seront utilisÃ©s partout (les composants ElementDetails attendront une prop de type ElementData par exemple). Cela rejoint le principe dâ€™Interface Segregation (SOLID) : on crÃ©e des types prÃ©cis pour chaque besoin plutÃ´t quâ€™une mÃ©ga-interface fourre-tout. Par exemple, on peut avoir un type ElementBasicInfo pour la liste (juste symbole, numÃ©ro, catÃ©gorie pour colorer) et un type ElementFullInfo avec tous les champs pour la fiche. Chaque fonction nâ€™utilisera que le type dont elle a besoin, ainsi on limite les dÃ©pendances et on clarifie les contrats.
Gestion de lâ€™Ã©tat global vs local : On profitera du systÃ¨me rÃ©actif de Svelte. Pour lâ€™Ã©tat global (langue courante, filtres actifs, Ã©ventuellement lâ€™Ã©lÃ©ment sÃ©lectionnÃ© si on gÃ¨re en contexte global), on utilisera les Svelte stores. Par exemple un store currentFilters (readable/writable) accessible Ã  la fois par le composant Filtres et par le composant Tableau pour savoir quoi afficher. Idem pour currentLang. Lâ€™utilisation de stores dÃ©couplÃ©s permet de ne pas lier trop fortement les composants entre eux (principe dâ€™Inversion de DÃ©pendance : les composants dÃ©pendent dâ€™abstractions â€“ ici le store â€“ plutÃ´t que directement les uns des autres). Pour lâ€™Ã©tat purement local (ex: si un sous-composant a son toggling interne), on utilisera le setContext/getContext de Svelte ou des props classiques. On fera en sorte quâ€™un composant reÃ§oit en props tout ce dont il a besoin, au lieu dâ€™aller piocher globalement nâ€™importe oÃ¹ â€“ cela le rend plus rÃ©utilisable et testable en isolation.
Commentaires et documentation : MÃªme si le code est en principe clair, on ajoutera des commentaires pour les parties non triviales. Par exemple, une fonction complexe de calcul (mettons, dÃ©terminer tous les Ã©lÃ©ments radioactifs) sera commentÃ©e en en-tÃªte pour expliquer lâ€™algorithme ou la source de la rÃ¨gle. On documentera aussi les composants (quelles props ils acceptent, quels events ils Ã©mettent). Ceci suit le principe de lisibilitÃ© du code : un autre dÃ©veloppeur (ou lâ€™AI pair programmer comme Cursor) doit comprendre lâ€™intention sans effort. On peut gÃ©nÃ©rer un petit README technique du projet qui rappelle les conventions, lâ€™arborescence, comment ajouter un Ã©lÃ©ment ou une langueâ€¦
Respect des principes SOLID dans la mesure du possible : MÃªme si SOLID est originellement formulÃ© pour la POO, on peut en appliquer lâ€™esprit :
Single Responsibility : dÃ©jÃ  abordÃ© (un module = une tÃ¢che).
Open/Closed : anticiper lâ€™extension sans modif massive.
Liskov Substitution : sâ€™applique moins ici, mais par exemple si on a une classe ou fonction gÃ©nÃ©rique, toute spÃ©cialisation doit pouvoir la remplacer sans casse. ConcrÃ¨tement, si on avait plusieurs types de tableau (un complet vs un simplifiÃ©), ils devraient offrir la mÃªme interface dâ€™utilisation.
Interface Segregation : dÃ©jÃ  mentionnÃ© avec TS types â€“ Ã©viter les â€œgod objectsâ€.
Dependency Inversion : dÃ©coupler modules hauts niveaux et bas niveaux. Par ex, le composant UI de tableau nâ€™accÃ©dera pas directement Ã  fetch(url) pour les donnÃ©es, il appellera un service de donnÃ©es. Ainsi, si on change la source (JSON local vers API), on modifie le service mais pas le composant UI. On ... - Dependency Inversion : On Ã©vitera que les composants de haut niveau dÃ©pendent directement de modules de bas niveau concrets. On introduira des abstractions (interfaces ou fonctions intermÃ©diaires) pour dÃ©coupler. Par exemple, le composant qui affiche les dÃ©tails dâ€™un Ã©lÃ©ment ne lira pas lui-mÃªme dans le JSON, il fera appel Ã  un service de donnÃ©es (fetchElementData(id) dans un module sÃ©parÃ©). Ainsi, si lâ€™on change la source des donnÃ©es (passer dâ€™un JSON local Ã  une API externe), on nâ€™aura quâ€™Ã  modifier le service de donnÃ©es, sans toucher aux composants UI. Cela rend le systÃ¨me plus modulable et testable (on peut mock le service en tests).
Maintenir la propretÃ© du code : On suivra les standards de dÃ©veloppement recommandÃ©s dans lâ€™Ã©diteur (par ex. Cursor) : formattage automatique (Prettier), linting (ESLint) pour attraper les incohÃ©rences, structure de fichiers logique. Chaque composant Svelte sera dans son fichier dÃ©diÃ©, et on Ã©vitera les fichiers trop longs (>300 lignes) en subdivisant si nÃ©cessaire. On versionnera le code avec Git en faisant des commits atomiques et bien commentÃ©s (une fonctionnalitÃ© ou correction par commit). Cela facilite les revues et le suivi de lâ€™historique.
Commentaires et documentation du projet : MÃªme si lâ€™on souhaite que le code soit auto-explicatif, on ajoutera des commentaires lÃ  oÃ¹ câ€™est utile (logique complexe, hacks nÃ©cessaires, TODO futurs). On peut utiliser la syntaxe JSDoc pour documenter les fonctions TS importantes. Une documentation Markdown (README) du projet expliquera comment le code est organisÃ©, comment ajouter un Ã©lÃ©ment ou une langue, quelles conventions suivre â€“ cela aidera tout nouveau contributeur ou lâ€™IA dâ€™aide au codage (Cursor) Ã  comprendre le contexte.
En appliquant ces principes (SOLID, DRY) et bonnes pratiques, on sâ€™assure que le code du projet sera modulaire, lisible et facile Ã  maintenir sur le long terme. Cela permettra dâ€™accueillir sereinement de nouvelles fonctionnalitÃ©s ou contributions, tout en minimisant les bugs. Le dÃ©veloppement sera plus efficace et fiable, lâ€™outil Cursor pouvant dâ€™ailleurs mieux assister sur un code bien structurÃ©. En somme, ces rÃ¨gles garantissent une base de code saine pour notre application de tableau pÃ©riodique interactive, au bÃ©nÃ©fice des dÃ©veloppeurs comme des utilisateurs finaux.